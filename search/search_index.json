{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Swarm Manager","text":"<p>An industrial-grade autonomous drone swarm communication and intelligence system written in Rust, featuring military-grade security, consensus algorithms, and federated learning for autonomous swarm coordination.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>GitHub Repository</li> <li>Getting Started</li> <li>Architecture</li> <li>API Reference</li> <li>Security Guide</li> </ul>"},{"location":"#why-this-project","title":"Why This Project?","text":"<p>Modern drone swarms require robust, secure, and efficient communication systems. This project addresses critical challenges in:</p> <ul> <li>Security: Military-grade cryptography with zero compromises</li> <li>Reliability: Byzantine fault tolerance and self-healing networks</li> <li>Efficiency: Optimized for resource-constrained embedded systems</li> <li>Intelligence: Distributed AI through federated learning</li> <li>Safety: 100% safe Rust with compile-time guarantees</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#military-grade-security","title":"\ud83d\udd12 Military-Grade Security","text":"<ul> <li>ChaCha20-Poly1305 authenticated encryption</li> <li>Ed25519 digital signatures (256-bit security)</li> <li>X25519 key exchange with perfect forward secrecy</li> <li>BLAKE3 + SHA3-256 cryptographic hashing</li> <li>Replay attack protection</li> <li>Intrusion detection system</li> </ul>"},{"location":"#decentralized-mesh-networking","title":"\ud83c\udf10 Decentralized Mesh Networking","text":"<ul> <li>Adaptive multi-hop routing</li> <li>Self-healing network topology</li> <li>Support for 100+ drones</li> <li>Link quality monitoring</li> <li>Automatic route discovery</li> </ul>"},{"location":"#raft-based-consensus","title":"\ud83e\udd1d Raft-Based Consensus","text":"<ul> <li>Leader election with crash fault tolerance</li> <li>Replicated state machine</li> <li>Low-latency agreement (50ms heartbeat)</li> <li>Optimized for embedded systems</li> </ul>"},{"location":"#federated-learning","title":"\ud83e\udde0 Federated Learning","text":"<ul> <li>Decentralized model training</li> <li>Byzantine-resistant aggregation</li> <li>Privacy-preserving gradient sharing</li> <li>FedAvg algorithm implementation</li> </ul>"},{"location":"#swarm-intelligence","title":"\ud83e\uddec Swarm Intelligence","text":"<ul> <li>Particle Swarm Optimization (PSO): Multi-topology support (Star, Ring, Von Neumann, Pyramid)</li> <li>Ant Colony Optimization (ACO): 3D path planning with three algorithm variants</li> <li>Grey Wolf Optimizer (GWO): Multi-objective optimization with hierarchical search</li> </ul>"},{"location":"#performance-metrics","title":"Performance Metrics","text":"Metric Value Latency &lt; 50ms (local consensus) Throughput 1000+ messages/sec per drone Scalability 100+ drones per swarm Memory &lt; 512KB RAM Binary Size &lt; 200KB (optimized)"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#search-and-rescue","title":"Search and Rescue","text":"<p>Coordinate multiple drones for efficient area coverage, real-time discovery sharing, and adaptive mission planning.</p>"},{"location":"#agricultural-monitoring","title":"Agricultural Monitoring","text":"<p>Distributed crop monitoring, collaborative spraying operations, and federated learning for pest detection.</p>"},{"location":"#infrastructure-inspection","title":"Infrastructure Inspection","text":"<p>Bridge and building inspection with collaborative 3D mapping and automated fault detection.</p>"},{"location":"#military-applications","title":"Military Applications","text":"<p>Secure tactical communication, autonomous patrol systems, and distributed target tracking.</p>"},{"location":"#emergency-response","title":"Emergency Response","text":"<p>Disaster area assessment, communication relay networks, and resource coordination.</p>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>Language: Rust 1.70+</li> <li>Cryptography: ChaCha20-Poly1305, Ed25519, X25519, BLAKE3, SHA3</li> <li>Networking: IPv6, UDP/TCP, Custom mesh protocol</li> <li>Consensus: Raft-based SwarmRaft</li> <li>Serialization: Postcard (efficient binary format)</li> <li>No-std Compatible: Runs on embedded systems</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code># Clone the repository\ngit clone https://github.com/mahii6991/swarm-manager.git\ncd swarm-manager\n\n# Build the project\ncargo build --release\n\n# Run tests\ncargo test\n\n# Run example\ncargo run --example simple_swarm\n</code></pre> <p>Read the full Getting Started guide \u2192</p>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Discussions: Ask questions, share ideas, showcase your projects</li> <li>Issues: Report bugs or request features</li> <li>Pull Requests: Contribute code improvements</li> </ul>"},{"location":"#for-companies","title":"For Companies","text":""},{"location":"#ready-to-deploy-autonomous-drone-swarm-infrastructure","title":"Ready-to-Deploy Autonomous Drone Swarm Infrastructure","text":""},{"location":"#what-you-get","title":"What You Get","text":"Component Description Rust Swarm Core Battle-tested, memory-safe foundation with 13,500+ lines of production code Mesh Networking Self-healing, multi-hop communication supporting 100+ drones Distributed Consensus SwarmRaft protocol with Byzantine fault tolerance Collision Avoidance 4 algorithms (VO, RVO, ORCA, APF) + geofencing PX4/SITL Integration Ready for hardware-in-the-loop testing and real deployments Interactive GUI Real-time visualization dashboard for monitoring and control Mission Planning Waypoint navigation with survey patterns (lawnmower, spiral, grid) Failsafe Systems RTL, emergency land, altitude hold with configurable triggers Cryptographic Security ChaCha20-Poly1305 + Ed25519 for secure communications"},{"location":"#who-its-for","title":"Who It's For","text":"Industry Use Cases Drone Manufacturers Integrate swarm intelligence into your UAV product line Defense &amp; Dual-Use Tactical reconnaissance, perimeter security, ISR missions Security &amp; Surveillance Automated patrol, crowd monitoring, critical infrastructure Inspection &amp; Mapping Solar farms, pipelines, power lines, agricultural surveys Research Labs Academic research, algorithm development, swarm behavior studies Search &amp; Rescue Coordinated search patterns, area coverage optimization"},{"location":"#enterprise-features","title":"Enterprise Features","text":"<ul> <li>Priority Support - Direct engineering support with guaranteed response times</li> <li>Custom Integration - Tailored integration with your existing drone fleet</li> <li>Hardware Optimization - Embedded systems tuning for your specific platforms</li> <li>Training &amp; Onboarding - Technical workshops for your engineering team</li> <li>Source Code Access - Full source with modification rights for enterprise</li> <li>Compliance Assistance - Help with aviation regulatory requirements</li> </ul>"},{"location":"#get-started","title":"Get Started","text":"<p> Ready to deploy autonomous drone swarms? </p> <p> Contact for Commercial Licensing </p> <p> Schedule a Demo </p>"},{"location":"#license","title":"License","text":"Component License Core algorithms (PSO, ACO, GWO, WOA, etc.) Apache 2.0 (Open Source) Enterprise features Commercial license available <p>This project is licensed under the Apache License 2.0 - see LICENSE for details.</p> <p>Enterprise Licensing: For commercial deployments requiring dedicated support, custom integrations, or proprietary features, contact: m.s.rajpoot20@gmail.com</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this project in your research, please cite:</p> <pre><code>@software{swarm_manager_2025,\n  author = {Rajpoot, Mahendra Singh},\n  title = {Swarm Manager: Industrial-Grade Autonomous Drone Swarm System},\n  year = {2025},\n  publisher = {GitHub},\n  url = {https://github.com/mahii6991/swarm-manager}\n}\n</code></pre> <p>Built with Rust for Maximum Safety and Performance</p> <p>\"In swarms we trust, in cryptography we verify.\"</p>"},{"location":"MILITARY_INTEGRATION/","title":"Military Extensions Integration Guide","text":"<p>This document describes the architecture for separating commercial (open-source) and military (private) code in the Swarm Manager project.</p>"},{"location":"MILITARY_INTEGRATION/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PUBLIC REPOSITORY (Open Source)                       \u2502\n\u2502                    github.com/mahii6991/swarm-manager                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                        Core Modules                                \u2502  \u2502\n\u2502  \u2502  \u2022 algorithms/    - PSO, ACO, GWO, WOA, Hybrid                    \u2502  \u2502\n\u2502  \u2502  \u2022 consensus/     - Raft, PBFT, Hierarchical                      \u2502  \u2502\n\u2502  \u2502  \u2022 network/       - Mesh, MAVLink, ESP32, Routing                 \u2502  \u2502\n\u2502  \u2502  \u2022 control/       - Swarm, Collision, Mission, Task               \u2502  \u2502\n\u2502  \u2502  \u2022 safety/        - Crypto (ChaCha20/Ed25519), Security, Failsafe \u2502  \u2502\n\u2502  \u2502  \u2022 ml/            - Federated Learning                            \u2502  \u2502\n\u2502  \u2502  \u2022 system/        - Config, Telemetry, Clustering                 \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                     Extension Traits (src/extensions/)             \u2502  \u2502\n\u2502  \u2502  \u2022 CryptoProvider       - Pluggable cryptography                  \u2502  \u2502\n\u2502  \u2502  \u2022 TacticalProvider     - Pluggable tactical algorithms           \u2502  \u2502\n\u2502  \u2502  \u2022 SecureCommProvider   - Pluggable secure communications         \u2502  \u2502\n\u2502  \u2502  \u2022 ExtensionRegistry    - Runtime provider management             \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 Git Submodule + Cargo Dependency\n                                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   PRIVATE REPOSITORY (Restricted Access)                 \u2502\n\u2502                github.com/mahii6991/swarm-manager-military                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                    Military Extensions                             \u2502  \u2502\n\u2502  \u2502  \u2022 Post-quantum cryptography (Kyber, Dilithium, SPHINCS+)         \u2502  \u2502\n\u2502  \u2502  \u2022 Advanced tactical algorithms                                    \u2502  \u2502\n\u2502  \u2502  \u2022 Military-grade communication protocols                         \u2502  \u2502\n\u2502  \u2502  \u2022 Classified mission planning strategies                         \u2502  \u2502\n\u2502  \u2502  \u2022 Hardware-specific military integrations                        \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#for-commercial-users","title":"For Commercial Users","text":"<p>Commercial users clone the public repository and use the default implementations:</p> <pre><code># Clone public repository\ngit clone https://github.com/mahii6991/swarm-manager.git\ncd swarm-manager\n\n# Build with default features\ncargo build --release\n\n# Use in your project\n</code></pre> <pre><code>use drone_swarm_system::{\n    DefaultCryptoProvider,\n    DefaultTacticalProvider,\n    ExtensionRegistry,\n};\n\nfn main() {\n    // Use default (commercial) providers\n    let registry = ExtensionRegistry::new();\n\n    // Access providers\n    let crypto = registry.crypto();\n    println!(\"Using: {}\", crypto.provider_name());\n    // Output: \"DefaultCrypto (ChaCha20-Poly1305 + Ed25519)\"\n}\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#for-military-users","title":"For Military Users","text":"<p>Authorized users with access to the private repository:</p>"},{"location":"MILITARY_INTEGRATION/#initial-setup","title":"Initial Setup","text":"<pre><code># Clone public repository\ngit clone https://github.com/mahii6991/swarm-manager.git\ncd swarm-manager\n\n# Run military setup script (requires SSH access to private repo)\n./scripts/setup-military.sh\n\n# Or manually add submodule\ngit submodule add git@github.com:mahii6991/swarm-manager-military.git military\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#building-with-military-extensions","title":"Building with Military Extensions","text":"<pre><code># Build with military features\ncargo build --release --features military\n\n# Run tests with military features\ncargo test --features military\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#using-military-extensions","title":"Using Military Extensions","text":"<pre><code>use drone_swarm_system::{\n    ExtensionRegistry,\n    CryptoProvider,\n    TacticalProvider,\n};\n\n// Import military implementations (only available with 'military' feature)\n#[cfg(feature = \"military\")]\nuse swarm_manager_military::{\n    PostQuantumCrypto,\n    AdvancedTactical,\n};\n\nfn main() {\n    let mut registry = ExtensionRegistry::new();\n\n    #[cfg(feature = \"military\")]\n    {\n        // Replace default providers with military-grade implementations\n        registry.set_crypto_provider(Box::new(PostQuantumCrypto::new()));\n        registry.set_tactical_provider(Box::new(AdvancedTactical::new()));\n    }\n\n    let crypto = registry.crypto();\n    println!(\"Using: {}\", crypto.provider_name());\n    // Output: \"PostQuantumCrypto (Kyber + Dilithium)\"\n}\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#extension-traits","title":"Extension Traits","text":""},{"location":"MILITARY_INTEGRATION/#cryptoprovider","title":"CryptoProvider","text":"<p>Defines cryptographic operations:</p> <pre><code>pub trait CryptoProvider: Send + Sync {\n    fn encrypt(&amp;self, plaintext: &amp;[u8], key: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt;;\n    fn decrypt(&amp;self, ciphertext: &amp;[u8], key: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt;;\n    fn sign(&amp;self, data: &amp;[u8], private_key: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt;;\n    fn verify(&amp;self, data: &amp;[u8], signature: &amp;[u8], public_key: &amp;[u8]) -&gt; Result&lt;bool, CryptoError&gt;;\n    fn generate_signing_keypair(&amp;self) -&gt; Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;), CryptoError&gt;;\n    fn generate_exchange_keypair(&amp;self) -&gt; Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;), CryptoError&gt;;\n    fn key_exchange(&amp;self, our_private: &amp;[u8], their_public: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt;;\n    fn provider_name(&amp;self) -&gt; &amp;'static str;\n    fn security_level(&amp;self) -&gt; u32;\n}\n</code></pre> Implementation Algorithm Security Level Repository <code>DefaultCryptoProvider</code> ChaCha20-Poly1305 + Ed25519 256-bit Public <code>PostQuantumCrypto</code> Kyber + Dilithium Post-quantum Private"},{"location":"MILITARY_INTEGRATION/#tacticalprovider","title":"TacticalProvider","text":"<p>Defines tactical operations:</p> <pre><code>pub trait TacticalProvider: Send + Sync {\n    fn compute_formation(&amp;self, positions: &amp;[(DroneId, Position)], objective: &amp;TacticalObjective) -&gt; Result&lt;FormationPlan, TacticalError&gt;;\n    fn compute_threat_response(&amp;self, threat: &amp;ThreatAssessment, swarm_state: &amp;SwarmSnapshot) -&gt; Result&lt;ThreatResponse, TacticalError&gt;;\n    fn compute_evasion(&amp;self, drone_id: DroneId, current_pos: Position, current_vel: Velocity, threat_pos: Position) -&gt; Result&lt;EvasionManeuver, TacticalError&gt;;\n    fn provider_name(&amp;self) -&gt; &amp;'static str;\n}\n</code></pre> Implementation Capabilities Repository <code>DefaultTacticalProvider</code> Grid formations, basic threat response Public <code>AdvancedTactical</code> Classified formations, advanced threat response Private"},{"location":"MILITARY_INTEGRATION/#securecommprovider","title":"SecureCommProvider","text":"<p>Defines secure communication operations:</p> <pre><code>pub trait SecureCommProvider: Send + Sync {\n    fn send_secure(&amp;self, to: DroneId, message: &amp;[u8], priority: MessagePriority) -&gt; Result&lt;(), CommError&gt;;\n    fn broadcast_secure(&amp;self, message: &amp;[u8], priority: MessagePriority) -&gt; Result&lt;(), CommError&gt;;\n    fn receive(&amp;self) -&gt; Result&lt;Option&lt;SecureMessage&gt;, CommError&gt;;\n    fn is_channel_secure(&amp;self) -&gt; bool;\n    fn rotate_keys(&amp;mut self) -&gt; Result&lt;(), CommError&gt;;\n    fn provider_name(&amp;self) -&gt; &amp;'static str;\n}\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#creating-the-private-repository","title":"Creating the Private Repository","text":"<p>To set up the private military repository:</p>"},{"location":"MILITARY_INTEGRATION/#1-create-repository-structure","title":"1. Create Repository Structure","text":"<pre><code>swarm-manager-military/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 crypto/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u251c\u2500\u2500 kyber.rs\n\u2502   \u2502   \u2514\u2500\u2500 dilithium.rs\n\u2502   \u251c\u2500\u2500 tactical/\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 advanced.rs\n\u2502   \u2514\u2500\u2500 comm/\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 secure.rs\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#2-cargotoml-for-private-crate","title":"2. Cargo.toml for Private Crate","text":"<pre><code>[package]\nname = \"swarm-manager-military\"\nversion = \"0.1.0\"\nedition = \"2021\"\npublish = false  # Never publish to crates.io\n\n[dependencies]\nswarm-manager = { git = \"https://github.com/mahii6991/swarm-manager.git\" }\n\n# Post-quantum cryptography\npqcrypto-kyber = \"0.8\"\npqcrypto-dilithium = \"0.5\"\npqcrypto-sphincsplus = \"0.7\"\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#3-implement-extension-traits","title":"3. Implement Extension Traits","text":"<pre><code>// src/lib.rs\nuse drone_swarm_system::extensions::{\n    CryptoProvider, CryptoError,\n    TacticalProvider, TacticalError,\n    // ... other traits\n};\n\nmod crypto;\nmod tactical;\nmod comm;\n\npub use crypto::PostQuantumCrypto;\npub use tactical::AdvancedTactical;\npub use comm::MilitaryComm;\n</code></pre> <pre><code>// src/crypto/mod.rs\nuse drone_swarm_system::extensions::{CryptoProvider, CryptoError};\n\npub struct PostQuantumCrypto {\n    // Kyber for key exchange\n    // Dilithium for signatures\n}\n\nimpl CryptoProvider for PostQuantumCrypto {\n    fn encrypt(&amp;self, plaintext: &amp;[u8], key: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt; {\n        // Post-quantum encryption implementation\n    }\n\n    // ... implement other methods\n\n    fn provider_name(&amp;self) -&gt; &amp;'static str {\n        \"PostQuantumCrypto (Kyber + Dilithium)\"\n    }\n\n    fn security_level(&amp;self) -&gt; u32 {\n        384 // Post-quantum security level\n    }\n}\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#security-considerations","title":"Security Considerations","text":""},{"location":"MILITARY_INTEGRATION/#export-control-compliance","title":"Export Control Compliance","text":"<ul> <li>ITAR: International Traffic in Arms Regulations</li> <li>EAR: Export Administration Regulations</li> </ul> <p>Ensure all military extensions comply with applicable export control regulations before deployment.</p>"},{"location":"MILITARY_INTEGRATION/#access-control","title":"Access Control","text":"<ul> <li>Private repository requires SSH key authentication</li> <li>Use GitHub Teams for access management</li> <li>Implement audit logging for access events</li> </ul>"},{"location":"MILITARY_INTEGRATION/#code-separation","title":"Code Separation","text":"<ul> <li>Military code NEVER enters public git history</li> <li>All military-specific logic stays in private repository</li> <li>Public repository contains only trait definitions and default implementations</li> </ul>"},{"location":"MILITARY_INTEGRATION/#cicd-configuration","title":"CI/CD Configuration","text":""},{"location":"MILITARY_INTEGRATION/#public-repository-githubworkflowsciyml","title":"Public Repository (.github/workflows/ci.yml)","text":"<pre><code>name: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build (Commercial)\n        run: cargo build --release\n      - name: Test (Commercial)\n        run: cargo test\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#private-repository-githubworkflowsciyml","title":"Private Repository (.github/workflows/ci.yml)","text":"<pre><code>name: Military CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: self-hosted  # Use private runners\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          submodules: recursive\n      - name: Build (Military)\n        run: cargo build --release --features military\n      - name: Test (Military)\n        run: cargo test --features military\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"MILITARY_INTEGRATION/#repository-not-found-when-setting-up-military-extensions","title":"\"Repository not found\" when setting up military extensions","text":"<p>Ensure you have SSH access to the private repository:</p> <pre><code>ssh -T git@github.com\n</code></pre>"},{"location":"MILITARY_INTEGRATION/#build-fails-with-feature-military-requires-swarm-manager-military","title":"Build fails with \"feature military requires swarm-manager-military\"","text":"<p>The military feature requires the private repository. Either: 1. Set up the military submodule (authorized users only) 2. Build without the military feature: <code>cargo build</code></p>"},{"location":"MILITARY_INTEGRATION/#submodule-out-of-sync","title":"Submodule out of sync","text":"<p>Update the submodule to the latest version:</p> <pre><code>git submodule update --remote military\n</code></pre>"},{"location":"community/","title":"Community","text":"<p>Connect with the Swarm Manager community and find answers to common questions.</p>"},{"location":"community/#getting-help","title":"Getting Help","text":"<ul> <li>FAQ - Frequently asked questions and troubleshooting</li> <li>GitHub Issues - Report bugs or request features</li> <li>Discussions - Ask questions and share ideas</li> </ul>"},{"location":"community/#contributing","title":"Contributing","text":"<p>We welcome contributions from the community! See our Developer Guide for information on how to get started.</p>"},{"location":"community/#quick-links","title":"Quick Links","text":"<ul> <li> <p> FAQ</p> <p>Find answers to frequently asked questions</p> <p> View FAQ</p> </li> <li> <p> GitHub</p> <p>Report issues and contribute to the project</p> <p> GitHub repo</p> </li> </ul>"},{"location":"community/faq/","title":"Frequently Asked Questions","text":"<p>Common questions and troubleshooting guide for the drone swarm system.</p>"},{"location":"community/faq/#general-questions","title":"General Questions","text":""},{"location":"community/faq/#what-is-this-project","title":"What is this project?","text":"<p>A production-ready Rust library for autonomous drone swarm coordination, featuring: - Multi-drone formation control and path planning - Enterprise-grade end-to-end encryption - Swarm intelligence algorithms (PSO, ACO, GWO) - Federated learning for collaborative AI - Embedded systems support (no_std compatible)</p>"},{"location":"community/faq/#who-is-this-for","title":"Who is this for?","text":"<ul> <li>Researchers: Academic swarm robotics and multi-agent systems research</li> <li>Developers: Building commercial drone applications (agriculture, delivery, monitoring)</li> <li>Defense contractors: Secure autonomous swarm systems</li> <li>Hobbyists: DIY drone swarm projects and educational purposes</li> <li>Embedded engineers: Real-time systems on STM32/ESP32/nRF52</li> </ul>"},{"location":"community/faq/#what-drones-are-supported","title":"What drones are supported?","text":"<p>The library is hardware-agnostic and works with any drone platform via integration: - Flight controllers: PX4, ArduPilot (via MAVLink) - Microcontrollers: STM32F4/F7/H7, ESP32, nRF52, RISC-V - Companion computers: Raspberry Pi, Jetson Nano, ODROID - Simulators: Gazebo, AirSim, JMAVSim</p> <p>See Hardware Integration Guide for details.</p>"},{"location":"community/faq/#is-this-production-ready","title":"Is this production-ready?","text":"<p>Current status: Beta (v0.1.0)</p> <p>\u2705 Production-ready components: - Core swarm algorithms (100% test coverage) - Cryptography (audited primitives from RustCrypto) - Formation control (tested with 100+ drone simulations) - Network stack (stress-tested with million-message runs)</p> <p>\u26a0\ufe0f Needs more testing: - Real-world hardware deployment (limited field testing) - Long-duration missions (&gt;24 hours) - Adversarial scenarios (security hardening in progress)</p> <p>Recommendation: Use for research and prototypes now; production after v1.0 (Q3 2025)</p>"},{"location":"community/faq/#technical-questions","title":"Technical Questions","text":""},{"location":"community/faq/#whats-the-minimum-hardware-requirement","title":"What's the minimum hardware requirement?","text":"<p>Embedded (no_std): - CPU: ARM Cortex-M4+ @ 80 MHz - RAM: 64 KB minimum, 128 KB recommended - Flash: 256 KB - Network: WiFi or LoRa radio</p> <p>Desktop/Server: - Any x86_64 or ARM64 CPU - RAM: 512 MB - OS: Linux, macOS, Windows</p>"},{"location":"community/faq/#how-many-drones-can-one-swarm-support","title":"How many drones can one swarm support?","text":"<p>Theoretical limits: - WiFi mesh (2.4 GHz): 200 drones per swarm - LoRa long-range: 500+ drones with hierarchical clustering - 5 GHz WiFi: 300 drones</p> <p>Practical recommendations: - 10-50 drones: Excellent performance, &lt;10 ms latency - 50-100 drones: Good performance, &lt;20 ms latency - 100-200 drones: Acceptable performance, &lt;50 ms latency - 200+ drones: Requires hierarchical sub-swarms</p> <p>Memory usage: ~12-24 KB per drone</p>"},{"location":"community/faq/#is-gps-required","title":"Is GPS required?","text":"<p>No, but it helps. The system supports multiple positioning methods:</p> <ol> <li>GPS/GNSS: Outdoor absolute positioning</li> <li>Visual odometry: Camera-based SLAM for indoor/GPS-denied</li> <li>UWB (Ultra-Wideband): High-precision indoor positioning</li> <li>IMU dead reckoning: Backup for short-term GPS loss</li> <li>Relative positioning: Formation control without absolute coordinates</li> </ol> <p>See <code>Position</code> struct documentation for coordinate system details.</p>"},{"location":"community/faq/#whats-the-communication-range","title":"What's the communication range?","text":"<p>WiFi (IEEE 802.11n/ac): - Line-of-sight: 500-1000m - Urban/obstacles: 100-300m - Data rate: 10-100 Mbps</p> <p>LoRa (868/915 MHz): - Line-of-sight: 10-15 km - Urban: 2-5 km - Data rate: 0.3-50 kbps (low bandwidth, long range)</p> <p>Mesh routing extends range through multi-hop forwarding.</p>"},{"location":"community/faq/#how-secure-is-the-encryption","title":"How secure is the encryption?","text":"<p>Enterprise-grade security: - Encryption: ChaCha20-Poly1305 AEAD (256-bit keys) - Signatures: Ed25519 (128-bit security) - Key exchange: ECDH with Curve25519 - Forward secrecy: Session keys rotated every 24 hours</p> <p>Threat model: - \u2705 Protects against: Eavesdropping, message tampering, replay attacks - \u2705 Resistant to: Brute force, side-channel attacks (constant-time crypto) - \u26a0\ufe0f Vulnerable to: Quantum computers (post-quantum upgrade planned Q3 2025)</p> <p>Audits: Uses RustCrypto primitives (community-audited, FIPS-approved algorithms)</p>"},{"location":"community/faq/#can-i-use-this-commercially","title":"Can I use this commercially?","text":"<p>Yes! Licensed under Apache 2.0: - \u2705 Use in commercial products - \u2705 Modify and distribute - \u2705 Patent grant included - \u2705 No attribution in binary required (but appreciated!)</p> <p>Requirements: - Include LICENSE and NOTICE files in source distributions - State changes made to the code</p> <p>No royalties, no fees, no restrictions.</p>"},{"location":"community/faq/#build-and-compilation","title":"Build and Compilation","text":""},{"location":"community/faq/#build-fails-with-cannot-find-crate-alloc","title":"Build fails with \"cannot find crate <code>alloc</code>\"","text":"<p>Cause: You're trying to build a no_std example without a target specified.</p> <p>Solution: <pre><code># For embedded (e.g., STM32):\ncargo build --example stm32_deployment --target thumbv7em-none-eabihf --release\n\n# For desktop (std):\ncargo build --example simple_swarm --features std\n</code></pre></p>"},{"location":"community/faq/#error-requires-std-feature-when-building-for-embedded","title":"\"error: requires <code>std</code> feature\" when building for embedded","text":"<p>Cause: Some dependencies require <code>std</code> but you're building no_std.</p> <p>Solution: Disable default features and enable <code>no_std</code> feature: <pre><code>[dependencies]\nswarm-manager = { version = \"0.1\", default-features = false, features = [\"no_std\"] }\n</code></pre></p>"},{"location":"community/faq/#linker-error-undefined-reference-to-_unwind_resume","title":"Linker error: \"undefined reference to <code>_Unwind_Resume</code>\"","text":"<p>Cause: Missing panic handler or runtime for no_std.</p> <p>Solution: Add panic handler: <pre><code>#![no_std]\nuse panic_halt as _;  // Simple panic handler\n\n// Or for production:\nuse panic_probe as _;  // Logging panic handler\n</code></pre></p>"},{"location":"community/faq/#slow-compile-times","title":"Slow compile times","text":"<p>Solutions:</p> <ol> <li> <p>Use sccache (shared compilation cache): <pre><code>cargo install sccache\nexport RUSTC_WRAPPER=sccache\n</code></pre></p> </li> <li> <p>Parallel codegen: <pre><code># .cargo/config.toml\n[build]\njobs = 8  # Use 8 parallel jobs\n</code></pre></p> </li> <li> <p>Link with LLD (faster linker): <pre><code># .cargo/config.toml\n[target.x86_64-unknown-linux-gnu]\nlinker = \"clang\"\nrustflags = [\"-C\", \"link-arg=-fuse-ld=lld\"]\n</code></pre></p> </li> </ol>"},{"location":"community/faq/#runtime-errors","title":"Runtime Errors","text":""},{"location":"community/faq/#encryptionerrornonceexhaustion","title":"<code>EncryptionError::NonceExhaustion</code>","text":"<p>Cause: Encrypted &gt;2^32 messages with same key (nonce wraparound).</p> <p>Solution: Automatically handled by key rotation. If you see this: <pre><code>// Manual key rotation (normally automatic):\ncrypto.rotate_keys()?;\n</code></pre></p> <p>Prevention: Enable <code>auto_key_rotation</code> feature (enabled by default).</p>"},{"location":"community/faq/#swarmerrorconsensustimeout","title":"<code>SwarmError::ConsensusTimeout</code>","text":"<p>Cause: Raft consensus couldn't achieve quorum (network partition or &gt;50% nodes offline).</p> <p>Solution: <pre><code>// Check cluster health:\nif consensus.get_cluster_health() &lt; 0.5 {\n    // Less than half nodes available\n    consensus.trigger_election()?;\n}\n\n// Increase timeout for high-latency networks:\nlet config = RaftConfig {\n    election_timeout: Duration::from_secs(5),  // Default: 3s\n    ..Default::default()\n};\n</code></pre></p>"},{"location":"community/faq/#pathplanningerrornovalidpath","title":"<code>PathPlanningError::NoValidPath</code>","text":"<p>Cause: No collision-free path found (too many obstacles or impossible constraints).</p> <p>Solution: <pre><code>// 1. Increase PSO iterations:\noptimizer.set_max_iterations(200)?;  // Default: 100\n\n// 2. Relax constraints:\noptimizer.set_min_clearance(5.0)?;  // Reduce from 10.0m\n\n// 3. Use ACO instead (better for complex obstacles):\nlet aco_planner = ACOPathPlanner::new(start, goal, aco_config)?;\nlet path = aco_planner.optimize()?;\n</code></pre></p>"},{"location":"community/faq/#memory-allocation-failure-on-embedded","title":"Memory allocation failure on embedded","text":"<p>Cause: Heap exhaustion (too many simultaneous neighbors or large messages).</p> <p>Solution: <pre><code>// Use heapless collections with bounded capacity:\nuse heapless::Vec;\nconst MAX_NEIGHBORS: usize = 10;  // Limit neighbors\n\nlet mut network = MeshNetwork::new_with_capacity::&lt;MAX_NEIGHBORS&gt;(drone_id);\n</code></pre></p> <p>Memory tuning: - Reduce <code>MAX_NEIGHBORS</code> (default: 20) - Limit <code>MAX_MESSAGE_SIZE</code> (default: 4096 bytes) - Disable unused features (saves ~20-50 KB)</p>"},{"location":"community/faq/#network-issues","title":"Network Issues","text":""},{"location":"community/faq/#drones-cant-discover-each-other","title":"Drones can't discover each other","text":"<p>Checklist:</p> <ol> <li> <p>Same network? <pre><code>// All drones must use same network ID:\nlet config = NetworkConfig {\n    network_id: 0x1234,  // Must match\n    ..Default::default()\n};\n</code></pre></p> </li> <li> <p>Firewall blocking? <pre><code># Allow UDP port 8080 (default):\nsudo ufw allow 8080/udp\n</code></pre></p> </li> <li> <p>Multicast working? <pre><code># Test multicast (send on one device, receive on another):\n# Sender:\necho \"test\" | socat - UDP-DATAGRAM:224.0.0.251:8080,broadcast\n\n# Receiver:\nsocat UDP-RECV:8080,ip-add-membership=224.0.0.251:0.0.0.0 -\n</code></pre></p> </li> <li> <p>Hello messages enabled? <pre><code>network.start_discovery()?;  // Sends periodic Hello\n</code></pre></p> </li> </ol>"},{"location":"community/faq/#high-packet-loss-5","title":"High packet loss (&gt;5%)","text":"<p>Causes and solutions:</p> <ol> <li> <p>WiFi interference:    <pre><code>// Switch to less-congested channel:\nlet config = NetworkConfig {\n    wifi_channel: 11,  // Try 1, 6, or 11\n    ..Default::default()\n};\n</code></pre></p> </li> <li> <p>Too many drones on one channel:</p> </li> <li>Use 5 GHz if available (more channels)</li> <li> <p>Split swarm into sub-swarms</p> </li> <li> <p>Distance too far:    <pre><code>// Enable multi-hop routing:\nlet config = NetworkConfig {\n    max_hops: 5,  // Default: 3\n    ..Default::default()\n};\n</code></pre></p> </li> <li> <p>Message rate too high:    <pre><code>// Reduce broadcast frequency:\nlet config = NetworkConfig {\n    hello_interval: Duration::from_secs(2),  // Default: 1s\n    ..Default::default()\n};\n</code></pre></p> </li> </ol>"},{"location":"community/faq/#connection-refused-errors","title":"\"Connection refused\" errors","text":"<p>Cause: Peer not listening or incorrect address.</p> <p>Debug: <pre><code>// Check if peer is reachable:\nif let Some(neighbor) = network.get_neighbor(peer_id) {\n    println!(\"Peer address: {:?}\", neighbor.address);\n    println!(\"Last seen: {:?}\", neighbor.last_hello);\n} else {\n    println!(\"Peer not in neighbor table!\");\n}\n</code></pre></p>"},{"location":"community/faq/#algorithm-issues","title":"Algorithm Issues","text":""},{"location":"community/faq/#pso-not-converging","title":"PSO not converging","text":"<p>Tuning parameters:</p> <pre><code>let config = PSOConfig {\n    num_particles: 50,     // Increase from 30\n    max_iterations: 200,   // Increase from 100\n    inertia_weight: 0.7,   // Decrease from 0.9 (more exploration)\n    cognitive: 1.5,        // Personal best weight\n    social: 1.5,           // Swarm best weight\n    ..Default::default()\n};\n</code></pre> <p>Common issues: - Premature convergence: Increase <code>num_particles</code> or <code>inertia_weight</code> - Too slow: Decrease <code>max_iterations</code> or use <code>topology: Ring</code> (faster than <code>Global</code>) - Stuck in local minimum: Add <code>mutation_rate: 0.1</code> for random exploration</p>"},{"location":"community/faq/#aco-finds-suboptimal-paths","title":"ACO finds suboptimal paths","text":"<p>Parameter tuning:</p> <pre><code>let config = ACOConfig {\n    num_ants: 100,         // Increase from 50\n    alpha: 1.5,            // Increase pheromone importance\n    beta: 2.5,             // Increase heuristic importance\n    evaporation: 0.05,     // Decrease (slower pheromone decay)\n    variant: ACOVariant::MaxMinAntSystem,  // Better convergence\n    ..Default::default()\n};\n</code></pre> <p>Debugging: <pre><code>// Log best path cost per iteration:\nfor iteration in 0..100 {\n    aco.step()?;\n    println!(\"Iteration {}: Best cost = {:.2}\", iteration, aco.best_cost());\n}\n</code></pre></p>"},{"location":"community/faq/#gwo-stuck-in-local-optimum","title":"GWO stuck in local optimum","text":"<p>Solution: Use hybrid mode</p> <pre><code>let config = GWOConfig {\n    variant: GWOVariant::Hybrid,  // GWO + PSO\n    adaptive: true,                // Adaptive parameters\n    ..Default::default()\n};\n</code></pre>"},{"location":"community/faq/#performance-issues","title":"Performance Issues","text":""},{"location":"community/faq/#high-latency-100-ms","title":"High latency (&gt;100 ms)","text":"<p>Diagnosis:</p> <pre><code>// Add timing measurements:\nlet start = Instant::now();\nlet velocity = swarm.compute_control_velocity(dt);\nlet elapsed = start.elapsed();\nprintln!(\"Control loop: {:?}\", elapsed);\n</code></pre> <p>Common bottlenecks: 1. Cryptography: Batch encrypt multiple messages 2. Network: Use UDP instead of TCP for real-time data 3. Path planning: Run optimization less frequently (1 Hz instead of 10 Hz)</p> <p>Optimization: <pre><code>// Cache formation positions:\nlet target = swarm.get_target_position_cached()?;  // No recomputation\n</code></pre></p>"},{"location":"community/faq/#high-cpu-usage","title":"High CPU usage","text":"<p>Solutions:</p> <ol> <li> <p>Reduce control loop rate:    <pre><code>loop {\n    swarm.update(dt);\n    thread::sleep(Duration::from_millis(10));  // 100 Hz instead of 1000 Hz\n}\n</code></pre></p> </li> <li> <p>Disable unused features:    <pre><code>[dependencies]\nswarm-manager = { version = \"0.1\", default-features = false, features = [\"swarm\", \"pso\"] }\n</code></pre></p> </li> <li> <p>Use release mode:    <pre><code>cargo build --release  # 10-100x faster than debug\n</code></pre></p> </li> </ol>"},{"location":"community/faq/#battery-drains-too-fast","title":"Battery drains too fast","text":"<p>Power optimization:</p> <pre><code>// 1. Reduce network traffic:\nlet config = NetworkConfig {\n    hello_interval: Duration::from_secs(5),  // Less frequent\n    ..Default::default()\n};\n\n// 2. Sleep when idle:\nif !swarm.has_active_mission() {\n    swarm.enter_low_power_mode()?;\n}\n\n// 3. Optimize path for energy:\nlet fitness = |path: &amp;[Position]| {\n    let distance = calculate_path_length(path);\n    let energy = calculate_energy_cost(path);\n    distance * 0.3 + energy * 0.7  // Weight energy more\n};\n</code></pre>"},{"location":"community/faq/#testing-and-debugging","title":"Testing and Debugging","text":""},{"location":"community/faq/#how-do-i-test-without-real-drones","title":"How do I test without real drones?","text":"<p>Simulation options:</p> <ol> <li> <p>Unit tests (mock Position):    <pre><code>#[test]\nfn test_formation_circle() {\n    let drone_id = DroneId::new(1);\n    let pos = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let swarm = SwarmController::new(drone_id, pos);\n    // ... assertions\n}\n</code></pre></p> </li> <li> <p>Gazebo simulator:    <pre><code>roslaunch drone_swarm_gazebo swarm_50.launch\ncargo run --example gazebo_interface\n</code></pre></p> </li> <li> <p>SITL (Software In The Loop):    <pre><code># Start PX4 SITL instances:\n./start_sitl_swarm.sh 10  # 10 drones\ncargo run --example mavlink_swarm\n</code></pre></p> </li> </ol>"},{"location":"community/faq/#enable-debug-logging","title":"Enable debug logging","text":"<pre><code>// Cargo.toml:\n[dependencies]\nenv_logger = \"0.10\"\nlog = \"0.4\"\n\n// main.rs:\nuse log::{info, debug, warn, error};\n\nfn main() {\n    env_logger::init();\n    info!(\"Starting swarm...\");\n    debug!(\"Drone ID: {:?}\", drone_id);\n}\n</code></pre> <pre><code># Run with logging:\nRUST_LOG=debug cargo run\nRUST_LOG=drone_swarm_system=trace cargo run  # Very verbose\n</code></pre>"},{"location":"community/faq/#capture-network-traffic","title":"Capture network traffic","text":"<pre><code># Wireshark/tcpdump:\nsudo tcpdump -i wlan0 -w swarm_capture.pcap port 8080\n\n# Analyze in Wireshark:\nwireshark swarm_capture.pcap\n</code></pre>"},{"location":"community/faq/#hardware-specific-issues","title":"Hardware-Specific Issues","text":""},{"location":"community/faq/#stm32-panic-out-of-memory","title":"STM32: \"panic: out of memory\"","text":"<p>Cause: Heap too small in linker script.</p> <p>Solution: Edit <code>memory.x</code>: <pre><code>MEMORY\n{\n  FLASH : ORIGIN = 0x08000000, LENGTH = 1024K\n  RAM : ORIGIN = 0x20000000, LENGTH = 256K  /* Increase from 128K */\n}\n</code></pre></p>"},{"location":"community/faq/#esp32-wifi-connection-drops","title":"ESP32: WiFi connection drops","text":"<p>Cause: Power supply instability or WiFi power saving.</p> <p>Solution: <pre><code>// Disable WiFi power saving:\nesp_wifi_set_ps(WIFI_PS_NONE);\n\n// Increase TX power:\nesp_wifi_set_max_tx_power(84);  // Max 84 (21 dBm)\n</code></pre></p>"},{"location":"community/faq/#raspberry-pi-i2c-errors","title":"Raspberry Pi: I2C errors","text":"<p>Cause: I2C clock stretching issues.</p> <p>Solution: <pre><code># /boot/config.txt:\ndtparam=i2c_arm=on,i2c_arm_baudrate=100000\n\n# Increase timeout:\necho 1000 &gt; /sys/module/i2c_bcm2835/parameters/debug\n</code></pre></p>"},{"location":"community/faq/#contributing-and-support","title":"Contributing and Support","text":""},{"location":"community/faq/#how-do-i-report-a-bug","title":"How do I report a bug?","text":"<ol> <li>Check existing issues: GitHub Issues</li> <li>Provide details:</li> <li>Rust version: <code>rustc --version</code></li> <li>OS and architecture</li> <li>Minimal reproducible example</li> <li>Error messages and stack traces</li> <li>Submit issue: Use bug report template</li> </ol>"},{"location":"community/faq/#how-can-i-contribute","title":"How can I contribute?","text":"<ul> <li>Code contributions (submit PRs)</li> <li>Documentation improvements</li> <li>Bug reports and feature requests</li> <li>Hardware testing and benchmarks</li> </ul>"},{"location":"community/faq/#where-can-i-get-help","title":"Where can I get help?","text":"<ul> <li>GitHub Discussions: Community forum</li> <li>GitHub Issues: Report bugs</li> <li>Email: m.s.rajpoot20@gmail.com (critical security issues only)</li> </ul>"},{"location":"community/faq/#licensing-and-legal","title":"Licensing and Legal","text":""},{"location":"community/faq/#can-i-use-this-in-a-closed-source-product","title":"Can I use this in a closed-source product?","text":"<p>Yes! Apache 2.0 allows proprietary use. You must: - Include LICENSE and NOTICE files in source distributions - Provide attribution if distributing source code</p> <p>You do NOT need to: - Open-source your modifications - Pay royalties or fees - Attribute in binary/commercial products</p>"},{"location":"community/faq/#are-there-export-restrictions","title":"Are there export restrictions?","text":"<p>Potentially, depending on your country and use case:</p> <ul> <li>Encryption: ChaCha20 is generally export-controlled (check local laws)</li> <li>Drone technology: Some countries restrict autonomous systems</li> <li>Dual-use: Swarm tech may be subject to ITAR/EAR in USA</li> </ul> <p>Recommendation: Consult legal counsel for commercial/defense applications.</p>"},{"location":"community/faq/#what-if-i-find-a-security-vulnerability","title":"What if I find a security vulnerability?","text":"<p>DO NOT open a public issue. Email: security@example.com</p> <p>We follow responsible disclosure: 1. Report sent to security team 2. We acknowledge within 48 hours 3. Fix developed and tested 4. Coordinated disclosure (CVE assigned if applicable) 5. Public announcement after fix released</p> <p>Bug bounty: Not available yet (planned for v1.0).</p>"},{"location":"community/faq/#still-have-questions","title":"Still Have Questions?","text":"<ul> <li>Join GitHub Discussions</li> <li>Read the Full Documentation</li> <li>Check Examples</li> <li>Review API Reference</li> </ul> <p>This FAQ is continuously updated based on community questions. Last update: 2025-11-30</p>"},{"location":"developer-guide/","title":"Developer Guide","text":"<p>This section provides technical documentation for developers who want to understand the system internals, contribute to the project, or extend its functionality.</p>"},{"location":"developer-guide/#overview","title":"Overview","text":"<p>The Developer Guide includes:</p> <ul> <li>Architecture - System design, components, and communication patterns</li> <li>Security - Security model, authentication, and best practices</li> </ul>"},{"location":"developer-guide/#contributing","title":"Contributing","text":"<p>We welcome contributions! Before submitting a pull request, please:</p> <ol> <li>Review the architecture documentation</li> <li>Follow the coding style guidelines</li> <li>Write tests for new functionality</li> <li>Update documentation as needed</li> </ol>"},{"location":"developer-guide/#quick-links","title":"Quick Links","text":"<ul> <li> <p> Architecture</p> <p>Understand the system design and component interactions</p> <p> View architecture</p> </li> <li> <p> Security</p> <p>Learn about the security model and authentication mechanisms</p> <p> Security docs</p> </li> </ul>"},{"location":"developer-guide/architecture/","title":"System Architecture","text":"<p>This document provides a comprehensive overview of the Drone Swarm Communication System architecture.</p>"},{"location":"developer-guide/architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Layered Architecture</li> <li>Core Modules</li> <li>Data Flow</li> <li>Design Principles</li> <li>Technology Decisions</li> </ul>"},{"location":"developer-guide/architecture/#overview","title":"Overview","text":"<p>The system follows a layered architecture pattern, separating concerns across six distinct layers from hardware abstraction to application logic.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Application Layer                      \u2502\n\u2502              (Swarm Coordination &amp; Tasks)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Federated Learning Layer                    \u2502\n\u2502         (Distributed Model Training &amp; AI)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Consensus Layer                           \u2502\n\u2502           (SwarmRaft Distributed Agreement)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Security &amp; Crypto Layer                     \u2502\n\u2502    (Encryption, Signatures, Access Control, IDS)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Network Layer                               \u2502\n\u2502         (Mesh Routing, Multi-hop, Discovery)             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Hardware Abstraction Layer                    \u2502\n\u2502         (Embedded HAL, Microcontroller Support)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"developer-guide/architecture/#layered-architecture","title":"Layered Architecture","text":""},{"location":"developer-guide/architecture/#layer-1-hardware-abstraction-layer-hal","title":"Layer 1: Hardware Abstraction Layer (HAL)","text":"<p>Purpose: Provides a unified interface to hardware components across different platforms.</p> <p>Components: - Sensor interfaces (GPS, IMU, compass) - Radio module drivers (LoRa, Wi-Fi, Bluetooth) - Motor controllers - Power management - Hardware RNG (Random Number Generator)</p> <p>Key Features: - Platform-independent API - No-std compatible for embedded systems - Zero-cost abstractions - Compile-time hardware configuration</p> <p>Example: <pre><code>pub trait RadioDriver {\n    fn send(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn receive(&amp;mut self) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;\n    fn set_channel(&amp;mut self, channel: u8);\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#layer-2-network-layer","title":"Layer 2: Network Layer","text":"<p>Purpose: Manages mesh networking, routing, and message delivery.</p> <p>Components: - Mesh Network Manager: Maintains network topology - Routing Engine: Implements AODV (Ad-hoc On-Demand Distance Vector) routing - Link Quality Monitor: Tracks connection health - Message Queue: Buffers messages for reliable delivery</p> <p>Key Algorithms: 1. Route Discovery:    <pre><code>1. Source broadcasts RREQ (Route Request)\n2. Intermediate nodes forward RREQ\n3. Destination sends RREP (Route Reply)\n4. Source receives RREP and updates routing table\n</code></pre></p> <ol> <li> <p>Multi-hop Forwarding:    <pre><code>[Drone A] --hop1--&gt; [Drone B] --hop2--&gt; [Drone C]\n</code></pre></p> </li> <li> <p>Link Quality Calculation:    <pre><code>LQ = (0.4 \u00d7 RSSI) + (0.3 \u00d7 PDR) + (0.3 \u00d7 Latency)\n\nwhere:\n- RSSI: Received Signal Strength Indicator\n- PDR: Packet Delivery Ratio\n- Latency: Round-trip time\n</code></pre></p> </li> </ol> <p>Data Structures: <pre><code>pub struct MeshNetwork {\n    drone_id: DroneId,\n    neighbors: NeighborTable,\n    routing_table: RoutingTable,\n    message_queue: MessageQueue,\n}\n\npub struct RoutingEntry {\n    dest: DroneId,\n    next_hop: DroneId,\n    hop_count: u8,\n    link_quality: f32,\n    last_updated: Timestamp,\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#layer-3-security-crypto-layer","title":"Layer 3: Security &amp; Crypto Layer","text":"<p>Purpose: Provides end-to-end security for all communications.</p> <p>Components: - Encryption Engine: ChaCha20-Poly1305 AEAD - Signature Manager: Ed25519 digital signatures - Key Exchange: X25519 Diffie-Hellman - Hash Functions: BLAKE3 + SHA3-256 - Access Control: Role-based permissions - Intrusion Detection System (IDS): Anomaly detection</p> <p>Security Pipeline: <pre><code>[Plaintext]\n    \u2193\n[Sign with Ed25519]\n    \u2193\n[Encrypt with ChaCha20-Poly1305]\n    \u2193\n[Add nonce + timestamp]\n    \u2193\n[Ciphertext + MAC]\n\nDecryption reverses this process\n</code></pre></p> <p>Nonce Generation: <pre><code>// Prevents replay attacks\nnonce = counter || timestamp || random_bytes\n</code></pre></p> <p>Key Features: - Perfect forward secrecy - Replay attack protection (nonce tracking) - Byzantine fault tolerance - Rate limiting - Audit logging</p>"},{"location":"developer-guide/architecture/#layer-4-consensus-layer-swarmraft","title":"Layer 4: Consensus Layer (SwarmRaft)","text":"<p>Purpose: Enables distributed decision-making and state synchronization.</p> <p>Based on: Raft consensus algorithm</p> <p>Components: - Leader Election: Selects a leader drone - Log Replication: Ensures all drones have same state - State Machine: Applies committed log entries - Heartbeat Manager: Maintains leader liveness</p> <p>Raft States: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     timeout     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Follower \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502Candidate \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2191                            \u2502\n     \u2502                            \u2502 wins election\n     \u2502                            \u2193\n     \u2502                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 Leader \u2502\n         receives heartbeat  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Consensus Process: 1. Normal Operation:    - Leader sends heartbeats every 150ms    - Followers acknowledge    - Client requests go to leader</p> <ol> <li>Log Replication:</li> <li>Leader appends entry to local log</li> <li>Leader sends AppendEntries RPC to followers</li> <li>Followers append entry and acknowledge</li> <li>Leader commits entry when majority acknowledges</li> <li> <p>Leader notifies followers to commit</p> </li> <li> <p>Leader Election:</p> </li> <li>Follower times out (no heartbeat received)</li> <li>Follower becomes candidate, increments term</li> <li>Candidate votes for itself, requests votes</li> <li>Other nodes vote (at most one vote per term)</li> <li>Candidate with majority becomes leader</li> </ol> <p>Optimization for Drones: - Reduced heartbeat interval (50ms for low-latency) - Compact log storage (bounded memory) - Priority-based leader selection (battery, position)</p>"},{"location":"developer-guide/architecture/#layer-5-federated-learning-layer","title":"Layer 5: Federated Learning Layer","text":"<p>Purpose: Enables collaborative AI model training without sharing raw data.</p> <p>Components: - Model Manager: Maintains local neural network - Gradient Calculator: Computes model updates - Aggregator: Combines updates from multiple drones (FedAvg) - Byzantine Detector: Filters malicious updates</p> <p>Federated Averaging (FedAvg): <pre><code>Global Model Update:\nw(t+1) = \u03a3 (n_i / n) \u00d7 w_i(t)\n\nwhere:\n- w(t+1): New global model\n- n_i: Number of samples on drone i\n- n: Total samples across all drones\n- w_i(t): Local model update from drone i\n</code></pre></p> <p>Training Process: <pre><code>1. Leader broadcasts current global model\n2. Each drone trains on local data\n3. Drones send gradients (not raw data!) to leader\n4. Leader aggregates gradients using FedAvg\n5. Leader updates global model\n6. Repeat\n</code></pre></p> <p>Byzantine-Resistant Aggregation: <pre><code>// Krum algorithm: Select most trustworthy updates\nfn krum_aggregate(updates: &amp;[ModelUpdate]) -&gt; ModelUpdate {\n    let scores = compute_krum_scores(updates);\n    let trusted_updates = select_top_k(updates, scores, k);\n    average(trusted_updates)\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#layer-6-application-layer","title":"Layer 6: Application Layer","text":"<p>Purpose: Implements swarm coordination and mission-specific logic.</p> <p>Components: - Swarm Controller: Manages swarm behavior - Formation Manager: Maintains geometric formations - Task Allocator: Distributes tasks among drones - Path Planner: Uses ACO, PSO, GWO for navigation - Collision Avoidance: Prevents inter-drone collisions</p> <p>Swarm Intelligence Algorithms:</p> <ol> <li> <p>Particle Swarm Optimization (PSO):    <pre><code>Velocity Update:\nv_i = w\u00d7v_i + c1\u00d7r1\u00d7(pbest_i - x_i) + c2\u00d7r2\u00d7(gbest - x_i)\n\nPosition Update:\nx_i = x_i + v_i\n\nwhere:\n- w: inertia weight (0.7)\n- c1, c2: learning factors (1.5, 1.5)\n- pbest_i: personal best position\n- gbest: global best position\n</code></pre></p> </li> <li> <p>Ant Colony Optimization (ACO):    <pre><code>Pheromone Update:\n\u03c4_ij = (1-\u03c1)\u00d7\u03c4_ij + \u03a3 \u0394\u03c4_ij^k\n\nProbability of selecting edge (i,j):\np_ij = (\u03c4_ij^\u03b1 \u00d7 \u03b7_ij^\u03b2) / \u03a3 (\u03c4_ik^\u03b1 \u00d7 \u03b7_ik^\u03b2)\n\nwhere:\n- \u03c4_ij: pheromone on edge (i,j)\n- \u03b7_ij: heuristic (1/distance)\n- \u03c1: evaporation rate (0.1)\n- \u03b1, \u03b2: pheromone/heuristic importance (1.0, 2.0)\n</code></pre></p> </li> <li> <p>Grey Wolf Optimizer (GWO):    <pre><code>Position Update:\nX(t+1) = (X1 + X2 + X3) / 3\n\nwhere:\nX1 = X_\u03b1 - A1 \u00d7 |C1 \u00d7 X_\u03b1 - X|\nX2 = X_\u03b2 - A2 \u00d7 |C2 \u00d7 X_\u03b2 - X|\nX3 = X_\u03b4 - A3 \u00d7 |C3 \u00d7 X_\u03b4 - X|\n\n- X_\u03b1, X_\u03b2, X_\u03b4: Top 3 solutions\n- A, C: coefficient vectors\n</code></pre></p> </li> </ol>"},{"location":"developer-guide/architecture/#core-modules","title":"Core Modules","text":"<p>The codebase is organized into logical module groups under <code>src/</code>:</p>"},{"location":"developer-guide/architecture/#module-group-safety","title":"Module Group: <code>safety/</code>","text":"<p>Location: <code>src/safety/</code></p> <p>Submodules: - <code>crypto.rs</code> - Encryption &amp; signatures - <code>security.rs</code> - Intrusion detection - <code>failsafe.rs</code> - Safety behaviors - <code>fault_tolerance.rs</code> - Self-healing</p> <p>Key Types: <pre><code>pub struct CryptoContext {\n    signing_key: SigningKey,\n    verify_key: VerifyKey,\n    encryption_key: [u8; 32],\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#module-group-network","title":"Module Group: <code>network/</code>","text":"<p>Location: <code>src/network/</code></p> <p>Submodules: - <code>core.rs</code> - Mesh network management - <code>mesh.rs</code> - ESP32 mesh protocol - <code>mavlink.rs</code> - MAVLink interface - <code>esp32.rs</code> - ESP32-specific networking - <code>routing/</code> - Proactive routing &amp; link prediction</p> <p>Key Types: <pre><code>pub struct MeshNetwork {\n    drone_id: DroneId,\n    neighbors: NeighborTable,\n    routing_table: RoutingTable,\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#module-group-consensus","title":"Module Group: <code>consensus/</code>","text":"<p>Location: <code>src/consensus/</code></p> <p>Submodules: - <code>raft.rs</code> - SwarmRaft protocol - <code>pbft.rs</code> - Byzantine fault tolerance - <code>hierarchical.rs</code> - Hierarchical consensus - <code>merkle.rs</code> - Merkle tree logging</p> <p>Key Types: <pre><code>pub struct ConsensusEngine {\n    state: RaftState,\n    log: ReplicatedLog,\n    current_term: u64,\n    voted_for: Option&lt;DroneId&gt;,\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#module-group-ml","title":"Module Group: <code>ml/</code>","text":"<p>Location: <code>src/ml/</code></p> <p>Submodules: - <code>federated.rs</code> - Federated learning</p> <p>Key Types: <pre><code>pub struct FederatedLearner {\n    model: NeuralNetwork,\n    aggregator: Aggregator,\n    byzantine_detector: ByzantineDetector,\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#module-group-control","title":"Module Group: <code>control/</code>","text":"<p>Location: <code>src/control/</code></p> <p>Submodules: - <code>swarm.rs</code> - Formation control - <code>collision.rs</code> - Collision avoidance (VO, RVO, ORCA, APF) - <code>mission.rs</code> - Mission planning &amp; waypoints - <code>coordinator.rs</code> - Multi-drone coordination - <code>task.rs</code> - Task allocation</p> <p>Key Types: <pre><code>pub struct SwarmController {\n    drone_id: DroneId,\n    position: Position,\n    formation: Formation,\n    path_planner: PathPlanner,\n}\n</code></pre></p>"},{"location":"developer-guide/architecture/#module-group-algorithms","title":"Module Group: <code>algorithms/</code>","text":"<p>Location: <code>src/algorithms/</code></p> <p>Submodules: - <code>pso/</code> - Particle Swarm Optimization (basic &amp; advanced) - <code>aco.rs</code> - Ant Colony Optimization - <code>gwo.rs</code> - Grey Wolf Optimizer - <code>woa.rs</code> - Whale Optimization Algorithm - <code>hybrid.rs</code> - Hybrid optimizer - <code>selector.rs</code> - Deep RL algorithm selection</p>"},{"location":"developer-guide/architecture/#module-group-system","title":"Module Group: <code>system/</code>","text":"<p>Location: <code>src/system/</code></p> <p>Submodules: - <code>config.rs</code> - Configuration management - <code>telemetry.rs</code> - Health monitoring - <code>time.rs</code> - Time abstraction - <code>clustering.rs</code> - Cluster management</p>"},{"location":"developer-guide/architecture/#data-flow","title":"Data Flow","text":""},{"location":"developer-guide/architecture/#message-transmission-flow","title":"Message Transmission Flow","text":"<pre><code>Application\n    \u2502\n    \u2193 (plaintext message)\nSecurity Layer\n    \u2502 (encrypt + sign)\n    \u2193 (ciphertext + signature)\nNetwork Layer\n    \u2502 (add routing headers)\n    \u2193 (packet)\nHAL Layer\n    \u2502 (serialize)\n    \u2193 (bytes)\nRadio Hardware\n    \u2502\n    \u2193 (RF transmission)\n  [AIR]\n</code></pre>"},{"location":"developer-guide/architecture/#message-reception-flow","title":"Message Reception Flow","text":"<pre><code>Radio Hardware\n    \u2193 (bytes)\nHAL Layer\n    \u2193 (deserialize)\nNetwork Layer\n    \u2502 (check routing, forward if needed)\n    \u2193 (ciphertext + signature)\nSecurity Layer\n    \u2502 (verify + decrypt)\n    \u2193 (plaintext message)\nApplication\n</code></pre>"},{"location":"developer-guide/architecture/#consensus-state-replication","title":"Consensus State Replication","text":"<pre><code>Leader:\n  1. Receives client request\n  2. Appends to local log\n  3. Sends AppendEntries to followers\n  4. Waits for majority ACK\n  5. Commits entry\n  6. Notifies followers\n  7. Applies to state machine\n\nFollower:\n  1. Receives AppendEntries RPC\n  2. Validates term and log consistency\n  3. Appends entry to local log\n  4. Sends ACK to leader\n  5. Waits for commit notification\n  6. Applies to state machine\n</code></pre>"},{"location":"developer-guide/architecture/#design-principles","title":"Design Principles","text":""},{"location":"developer-guide/architecture/#1-safety-first","title":"1. Safety First","text":"<ul> <li>100% Safe Rust: No unsafe blocks</li> <li>Compile-time Guarantees: Ownership prevents data races</li> <li>No Heap Allocation: Predictable memory usage</li> <li>Bounded Collections: Prevents unbounded growth</li> </ul>"},{"location":"developer-guide/architecture/#2-defense-in-depth","title":"2. Defense in Depth","text":"<p>Multiple security layers: - Cryptographic protection (encryption + signatures) - Byzantine fault tolerance - Intrusion detection - Rate limiting - Audit logging</p>"},{"location":"developer-guide/architecture/#3-resource-efficiency","title":"3. Resource Efficiency","text":"<ul> <li>No-std Compatible: Runs on embedded systems</li> <li>Zero-copy: Minimal memory allocations</li> <li>Efficient Serialization: Postcard format</li> <li>Compact Binary: &lt; 200KB release build</li> </ul>"},{"location":"developer-guide/architecture/#4-modularity","title":"4. Modularity","text":"<ul> <li>Clear separation of concerns</li> <li>Loosely coupled modules</li> <li>Well-defined interfaces</li> <li>Dependency injection</li> </ul>"},{"location":"developer-guide/architecture/#5-testability","title":"5. Testability","text":"<ul> <li>Unit tests for each module</li> <li>Integration tests for interactions</li> <li>Property-based testing for crypto</li> <li>Simulation environment</li> </ul>"},{"location":"developer-guide/architecture/#technology-decisions","title":"Technology Decisions","text":""},{"location":"developer-guide/architecture/#why-rust","title":"Why Rust?","text":"<ul> <li>Memory Safety: No buffer overflows, use-after-free, data races</li> <li>Performance: Zero-cost abstractions, no GC pauses</li> <li>Embedded Support: Excellent no-std ecosystem</li> <li>Tooling: Cargo, Clippy, rustfmt, rust-analyzer</li> </ul>"},{"location":"developer-guide/architecture/#why-chacha20-poly1305","title":"Why ChaCha20-Poly1305?","text":"<ul> <li>Speed: Faster than AES on non-AES-NI hardware</li> <li>Security: Authenticated encryption (AEAD)</li> <li>Simplicity: Single algorithm for confidentiality + integrity</li> <li>Side-channel Resistance: Constant-time implementation</li> </ul>"},{"location":"developer-guide/architecture/#why-raft-consensus","title":"Why Raft Consensus?","text":"<ul> <li>Understandability: Easier to reason about than Paxos</li> <li>Proven: Used in production (etcd, Consul, etc.)</li> <li>Crash Fault Tolerance: Tolerates f failures with 2f+1 nodes</li> <li>Strong Consistency: Linearizable reads/writes</li> </ul>"},{"location":"developer-guide/architecture/#why-federated-learning","title":"Why Federated Learning?","text":"<ul> <li>Privacy: Raw data never leaves drone</li> <li>Bandwidth: Share gradients (small) not datasets (large)</li> <li>Robustness: Byzantine-resistant aggregation</li> <li>Scalability: Trains across distributed drones</li> </ul>"},{"location":"developer-guide/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"developer-guide/architecture/#time-complexity","title":"Time Complexity","text":"Operation Complexity Message Routing O(log n) Neighbor Discovery O(n) Consensus Agreement O(n) Formation Update O(1) Path Planning (ACO) O(m \u00d7 n)"},{"location":"developer-guide/architecture/#space-complexity","title":"Space Complexity","text":"Component Memory Usage Routing Table O(n) neighbors Consensus Log O(k) entries (bounded) Message Queue O(m) messages (bounded) Crypto Context O(1) constant"},{"location":"developer-guide/architecture/#scalability","title":"Scalability","text":"<ul> <li>Network: Tested with 100+ drones</li> <li>Consensus: Optimal with 3-7 nodes (Raft limitation)</li> <li>Federated Learning: Linear scaling</li> <li>Formation Control: Handles 1000+ drones</li> </ul> <p>For implementation details, see the API Reference.</p>"},{"location":"developer-guide/security/","title":"Security Best Practices","text":"<p>This guide covers security best practices for deploying and operating the Drone Swarm Communication System.</p>"},{"location":"developer-guide/security/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Security Overview</li> <li>Key Management</li> <li>Cryptographic Best Practices</li> <li>Network Security</li> <li>Deployment Security</li> <li>Monitoring and Incident Response</li> <li>Security Checklist</li> </ul>"},{"location":"developer-guide/security/#security-overview","title":"Security Overview","text":"<p>The system implements defense in depth with multiple security layers:</p> <ol> <li>Cryptographic Layer: ChaCha20-Poly1305 encryption + Ed25519 signatures</li> <li>Network Layer: Byzantine fault tolerance + mesh routing</li> <li>Consensus Layer: Raft-based agreement prevents rogue commands</li> <li>Application Layer: Role-based access control + intrusion detection</li> <li>Physical Layer: Tamper detection + secure boot</li> </ol>"},{"location":"developer-guide/security/#key-management","title":"Key Management","text":""},{"location":"developer-guide/security/#do-use-hardware-based-key-generation","title":"DO: Use Hardware-Based Key Generation","text":"<p>Never use static seeds in production!</p> <pre><code>// \u274c BAD - Predictable keys\nlet seed = [42u8; 32];\nlet crypto = CryptoContext::new(seed);\n\n// \u2705 GOOD - Hardware RNG\nuse getrandom::getrandom;\n\nlet mut seed = [0u8; 32];\ngetrandom(&amp;mut seed).expect(\"RNG failure\");\nlet crypto = CryptoContext::new(seed);\n</code></pre>"},{"location":"developer-guide/security/#do-use-hardware-security-modules-hsm","title":"DO: Use Hardware Security Modules (HSM)","text":"<p>For production deployments, store private keys in secure hardware:</p> <ul> <li>TPM (Trusted Platform Module): For general-purpose platforms</li> <li>Secure Element: For embedded systems (e.g., ATECC608)</li> <li>HSM: For high-security environments</li> </ul> <pre><code>// Example with TPM\nuse tpm2::{Tpm2Context, KeyHandle};\n\nlet mut tpm = Tpm2Context::new()?;\nlet key_handle = tpm.create_primary_key()?;\n\n// Keys never leave the TPM\nlet signature = tpm.sign(key_handle, message)?;\n</code></pre>"},{"location":"developer-guide/security/#do-implement-key-rotation","title":"DO: Implement Key Rotation","text":"<p>Rotate cryptographic keys periodically:</p> <pre><code>pub struct KeySchedule {\n    current_key: [u8; 32],\n    next_key: [u8; 32],\n    rotation_interval: Duration,\n    last_rotation: Instant,\n}\n\nimpl KeySchedule {\n    pub fn should_rotate(&amp;self) -&gt; bool {\n        self.last_rotation.elapsed() &gt; self.rotation_interval\n    }\n\n    pub fn rotate(&amp;mut self) {\n        // Retire current key, promote next key\n        self.current_key = self.next_key;\n\n        // Generate new next key\n        getrandom(&amp;mut self.next_key).unwrap();\n\n        self.last_rotation = Instant::now();\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#do-implement-perfect-forward-secrecy","title":"DO: Implement Perfect Forward Secrecy","text":"<p>Use ephemeral key exchange for each session:</p> <pre><code>use x25519_dalek::{EphemeralSecret, PublicKey};\nuse rand_core::OsRng;\n\n// Generate ephemeral key pair\nlet secret = EphemeralSecret::random_from_rng(OsRng);\nlet public = PublicKey::from(&amp;secret);\n\n// Exchange public keys, compute shared secret\nlet shared_secret = secret.diffie_hellman(&amp;peer_public);\n\n// Derive session keys\nlet session_key = hash_kdf(&amp;shared_secret);\n</code></pre>"},{"location":"developer-guide/security/#cryptographic-best-practices","title":"Cryptographic Best Practices","text":""},{"location":"developer-guide/security/#nonce-management","title":"Nonce Management","text":"<p>CRITICAL: Never reuse nonces with the same key!</p> <pre><code>use std::sync::atomic::{AtomicU64, Ordering};\n\npub struct NonceGenerator {\n    counter: AtomicU64,\n    random_prefix: [u8; 4],\n}\n\nimpl NonceGenerator {\n    pub fn new() -&gt; Self {\n        let mut random_prefix = [0u8; 4];\n        getrandom(&amp;mut random_prefix).unwrap();\n\n        Self {\n            counter: AtomicU64::new(0),\n            random_prefix,\n        }\n    }\n\n    pub fn next(&amp;self) -&gt; [u8; 12] {\n        let mut nonce = [0u8; 12];\n\n        // Random prefix (4 bytes)\n        nonce[0..4].copy_from_slice(&amp;self.random_prefix);\n\n        // Timestamp (4 bytes)\n        let timestamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs() as u32;\n        nonce[4..8].copy_from_slice(&amp;timestamp.to_be_bytes());\n\n        // Counter (4 bytes)\n        let counter = self.counter.fetch_add(1, Ordering::SeqCst) as u32;\n        nonce[8..12].copy_from_slice(&amp;counter.to_be_bytes());\n\n        nonce\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#replay-attack-prevention","title":"Replay Attack Prevention","text":"<p>Track used nonces to prevent replay attacks:</p> <pre><code>use std::collections::HashSet;\nuse std::time::{Instant, Duration};\n\npub struct ReplayDetector {\n    seen_nonces: HashSet&lt;[u8; 12]&gt;,\n    window: Duration,\n    last_cleanup: Instant,\n}\n\nimpl ReplayDetector {\n    pub fn check_and_insert(&amp;mut self, nonce: &amp;[u8; 12]) -&gt; bool {\n        // Periodic cleanup\n        if self.last_cleanup.elapsed() &gt; Duration::from_secs(60) {\n            self.cleanup();\n        }\n\n        // Check if nonce was already seen\n        !self.seen_nonces.insert(*nonce)\n    }\n\n    fn cleanup(&amp;mut self) {\n        // Remove nonces older than window\n        self.seen_nonces.clear();\n        self.last_cleanup = Instant::now();\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#constant-time-operations","title":"Constant-Time Operations","text":"<p>Use constant-time comparisons to prevent timing attacks:</p> <pre><code>use subtle::ConstantTimeEq;\n\npub fn verify_mac(computed: &amp;[u8], received: &amp;[u8]) -&gt; bool {\n    // \u274c BAD - Vulnerable to timing attacks\n    // computed == received\n\n    // \u2705 GOOD - Constant time\n    computed.ct_eq(received).into()\n}\n</code></pre>"},{"location":"developer-guide/security/#network-security","title":"Network Security","text":""},{"location":"developer-guide/security/#rate-limiting","title":"Rate Limiting","text":"<p>Implement rate limiting to prevent DoS attacks:</p> <pre><code>use std::collections::HashMap;\nuse std::time::{Instant, Duration};\n\npub struct RateLimiter {\n    requests: HashMap&lt;DroneId, Vec&lt;Instant&gt;&gt;,\n    max_requests: usize,\n    window: Duration,\n}\n\nimpl RateLimiter {\n    pub fn check(&amp;mut self, drone_id: DroneId) -&gt; bool {\n        let now = Instant::now();\n        let timestamps = self.requests.entry(drone_id).or_default();\n\n        // Remove old timestamps\n        timestamps.retain(|&amp;t| now.duration_since(t) &lt; self.window);\n\n        // Check limit\n        if timestamps.len() &gt;= self.max_requests {\n            return false; // Rate limit exceeded\n        }\n\n        timestamps.push(now);\n        true\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#input-validation","title":"Input Validation","text":"<p>Always validate inputs at trust boundaries:</p> <pre><code>pub fn validate_message(msg: &amp;Message) -&gt; Result&lt;(), ValidationError&gt; {\n    // Check message size\n    if msg.payload.len() &gt; MAX_MESSAGE_SIZE {\n        return Err(ValidationError::MessageTooLarge);\n    }\n\n    // Check timestamp (prevent old/future messages)\n    let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();\n    let msg_time = msg.timestamp;\n\n    if msg_time &lt; now - 300 || msg_time &gt; now + 300 {\n        return Err(ValidationError::InvalidTimestamp);\n    }\n\n    // Check hop count (prevent routing loops)\n    if msg.hop_count &gt; MAX_HOPS {\n        return Err(ValidationError::TooManyHops);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"developer-guide/security/#intrusion-detection","title":"Intrusion Detection","text":"<p>Monitor for suspicious behavior:</p> <pre><code>pub struct IntrusionDetector {\n    failed_auth: HashMap&lt;DroneId, usize&gt;,\n    anomaly_score: HashMap&lt;DroneId, f32&gt;,\n}\n\nimpl IntrusionDetector {\n    pub fn record_failed_auth(&amp;mut self, drone_id: DroneId) {\n        let count = self.failed_auth.entry(drone_id).or_insert(0);\n        *count += 1;\n\n        if *count &gt; 5 {\n            self.trigger_alert(drone_id, \"Excessive failed authentications\");\n        }\n    }\n\n    pub fn detect_anomaly(&amp;mut self, drone_id: DroneId, behavior: &amp;Behavior) {\n        let score = compute_anomaly_score(behavior);\n        self.anomaly_score.insert(drone_id, score);\n\n        if score &gt; 0.8 {\n            self.trigger_alert(drone_id, \"Anomalous behavior detected\");\n        }\n    }\n\n    fn trigger_alert(&amp;self, drone_id: DroneId, reason: &amp;str) {\n        // Log to secure audit trail\n        log_security_event(drone_id, reason);\n\n        // Optionally quarantine drone\n        // quarantine(drone_id);\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#deployment-security","title":"Deployment Security","text":""},{"location":"developer-guide/security/#secure-boot","title":"Secure Boot","text":"<p>Verify firmware integrity before execution:</p> <pre><code>use sha3::{Sha3_256, Digest};\n\npub fn verify_firmware(firmware: &amp;[u8], expected_hash: &amp;[u8; 32]) -&gt; bool {\n    let mut hasher = Sha3_256::new();\n    hasher.update(firmware);\n    let hash = hasher.finalize();\n\n    hash.as_slice() == expected_hash\n}\n</code></pre>"},{"location":"developer-guide/security/#firmware-updates","title":"Firmware Updates","text":"<p>Always use signed firmware updates:</p> <pre><code>pub fn update_firmware(\n    new_firmware: &amp;[u8],\n    signature: &amp;Signature,\n    public_key: &amp;PublicKey\n) -&gt; Result&lt;(), UpdateError&gt; {\n    // 1. Verify signature\n    if !verify_signature(new_firmware, signature, public_key) {\n        return Err(UpdateError::InvalidSignature);\n    }\n\n    // 2. Verify version (prevent downgrade attacks)\n    let new_version = parse_version(new_firmware)?;\n    let current_version = get_current_version();\n\n    if new_version &lt; current_version {\n        return Err(UpdateError::DowngradeAttempt);\n    }\n\n    // 3. Verify hash\n    let expected_hash = get_expected_hash(new_version)?;\n    if !verify_firmware(new_firmware, &amp;expected_hash) {\n        return Err(UpdateError::HashMismatch);\n    }\n\n    // 4. Apply update\n    flash_firmware(new_firmware)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"developer-guide/security/#time-synchronization","title":"Time Synchronization","text":"<p>Use authenticated NTP to prevent time-based attacks:</p> <pre><code>use ntp::packet::NtpPacket;\n\npub fn sync_time_secure(ntp_server: &amp;str) -&gt; Result&lt;SystemTime, TimeError&gt; {\n    // Send NTP request\n    let packet = NtpPacket::new();\n    let response = send_ntp_request(ntp_server, &amp;packet)?;\n\n    // Verify NTP-MAC (Message Authentication Code)\n    if !verify_ntp_mac(&amp;response) {\n        return Err(TimeError::AuthenticationFailed);\n    }\n\n    // Extract time\n    let time = response.transmit_timestamp();\n\n    Ok(time)\n}\n</code></pre>"},{"location":"developer-guide/security/#monitoring-and-incident-response","title":"Monitoring and Incident Response","text":""},{"location":"developer-guide/security/#secure-logging","title":"Secure Logging","text":"<p>Log security events to tamper-resistant storage:</p> <pre><code>use sha3::{Sha3_256, Digest};\n\npub struct AuditLog {\n    entries: Vec&lt;LogEntry&gt;,\n    chain_hash: [u8; 32],\n}\n\nimpl AuditLog {\n    pub fn append(&amp;mut self, event: SecurityEvent) {\n        let mut entry = LogEntry {\n            timestamp: SystemTime::now(),\n            event,\n            previous_hash: self.chain_hash,\n        };\n\n        // Chain hash (prevents tampering)\n        let mut hasher = Sha3_256::new();\n        hasher.update(&amp;entry.previous_hash);\n        hasher.update(&amp;serialize(&amp;entry.event));\n        self.chain_hash = hasher.finalize().into();\n\n        entry.chain_hash = self.chain_hash;\n        self.entries.push(entry);\n    }\n\n    pub fn verify_integrity(&amp;self) -&gt; bool {\n        // Verify hash chain\n        let mut expected_hash = [0u8; 32];\n\n        for entry in &amp;self.entries {\n            let mut hasher = Sha3_256::new();\n            hasher.update(&amp;expected_hash);\n            hasher.update(&amp;serialize(&amp;entry.event));\n            expected_hash = hasher.finalize().into();\n\n            if entry.chain_hash != expected_hash {\n                return false;\n            }\n        }\n\n        true\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#incident-response","title":"Incident Response","text":"<p>Implement automated incident response:</p> <pre><code>pub fn handle_security_incident(incident: SecurityIncident) {\n    match incident {\n        SecurityIncident::FailedAuthentication(drone_id) =&gt; {\n            // Temporarily block drone\n            block_drone(drone_id, Duration::from_secs(300));\n            alert_operator(\"Repeated failed auth\", drone_id);\n        }\n\n        SecurityIncident::MalformedPacket(source) =&gt; {\n            // Drop packets from source\n            blacklist_source(source, Duration::from_secs(600));\n            alert_operator(\"Malformed packets detected\", source);\n        }\n\n        SecurityIncident::ConsensusAnomaly =&gt; {\n            // Trigger re-election\n            force_leader_election();\n            alert_operator(\"Consensus anomaly detected\", DroneId::new(0));\n        }\n\n        SecurityIncident::TamperDetected =&gt; {\n            // Emergency shutdown\n            initiate_safe_landing();\n            erase_keys();\n            alert_operator(\"Physical tamper detected\", DroneId::new(0));\n        }\n    }\n}\n</code></pre>"},{"location":"developer-guide/security/#security-checklist","title":"Security Checklist","text":""},{"location":"developer-guide/security/#before-deployment","title":"Before Deployment","text":"<ul> <li> Keys generated using hardware RNG</li> <li> Firmware signatures verified</li> <li> Secure boot enabled</li> <li> Debug interfaces disabled</li> <li> Default passwords changed</li> <li> Audit logging enabled</li> <li> Time synchronization configured</li> <li> Rate limiting enabled</li> <li> Intrusion detection active</li> <li> Backup recovery procedures tested</li> </ul>"},{"location":"developer-guide/security/#runtime-monitoring","title":"Runtime Monitoring","text":"<ul> <li> Monitor failed authentication attempts</li> <li> Track anomalous network behavior</li> <li> Verify consensus health</li> <li> Check log integrity</li> <li> Monitor resource usage (DoS detection)</li> <li> Validate firmware integrity</li> <li> Test failover mechanisms</li> </ul>"},{"location":"developer-guide/security/#incident-response_1","title":"Incident Response","text":"<ul> <li> Security incident response plan documented</li> <li> Emergency contact list maintained</li> <li> Forensic data collection procedures</li> <li> Backup systems ready</li> <li> Key revocation procedures</li> </ul>"},{"location":"developer-guide/security/#security-reporting","title":"Security Reporting","text":""},{"location":"developer-guide/security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>If you discover a security vulnerability:</p> <ol> <li>DO NOT open a public issue</li> <li>Email: security@swarm-manager.example.com</li> <li>Use PGP encryption (key on website)</li> <li>Include: description, reproduction steps, impact assessment</li> <li>Wait for acknowledgment before public disclosure</li> </ol>"},{"location":"developer-guide/security/#responsible-disclosure","title":"Responsible Disclosure","text":"<p>We follow a 90-day disclosure policy:</p> <ol> <li>Day 0: Report received</li> <li>Day 2: Acknowledgment sent</li> <li>Day 14: Fix developed and tested</li> <li>Day 30: Patch released</li> <li>Day 90: Public disclosure (if agreed)</li> </ol> <p>Security is everyone's responsibility. Stay vigilant!</p> <p>Back to Documentation Home</p>"},{"location":"hardware/","title":"Hardware","text":"<p>This section covers hardware integration guides for various platforms supported by the Swarm Manager system.</p>"},{"location":"hardware/#supported-platforms","title":"Supported Platforms","text":"<p>The system supports multiple hardware platforms for different use cases:</p> <ul> <li>ESP32 - Low-cost WiFi/Bluetooth microcontroller for lightweight drones</li> <li>PX4 - Professional autopilot platform for advanced drone operations</li> <li>STM32 - High-performance microcontroller for custom implementations</li> </ul>"},{"location":"hardware/#platform-comparison","title":"Platform Comparison","text":"Platform Use Case Communication Processing Power ESP32 Lightweight swarms WiFi/BLE Moderate PX4 Professional UAVs MAVLink High STM32 Custom hardware Flexible High"},{"location":"hardware/#quick-links","title":"Quick Links","text":"<ul> <li> <p> ESP32 Setup</p> <p>Configure ESP32-based drones for swarm communication</p> <p> ESP32 guide</p> </li> <li> <p> PX4 Integration</p> <p>Integrate with PX4-based autopilot systems</p> <p> PX4 guide</p> </li> <li> <p> STM32 Support</p> <p>Set up STM32 microcontrollers for custom builds</p> <p> STM32 guide</p> </li> </ul>"},{"location":"hardware/esp32/","title":"ESP32 WiFi Mesh Integration Guide","text":"<p>Build cost-effective drone swarm communication using ESP32 WiFi mesh networking.</p>"},{"location":"hardware/esp32/#why-esp32-for-drone-swarms","title":"Why ESP32 for Drone Swarms?","text":"<p>Advantages: - \u2705 Built-in WiFi/Bluetooth: No external radio needed - \u2705 Low cost: $5-10 per module - \u2705 Dual-core: Run network on one core, swarm logic on another - \u2705 240 MHz: Fast enough for real-time control - \u2705 Large RAM: 520 KB (plenty for swarm coordination) - \u2705 ESP-MESH: Native mesh networking protocol - \u2705 Rust support: esp-rs ecosystem is mature</p> <p>Trade-offs: - \u26a0\ufe0f Higher power consumption than STM32 (~150-200 mW vs 40-80 mW) - \u26a0\ufe0f No hard real-time guarantees (FreeRTOS scheduler) - \u26a0\ufe0f WiFi range limited to ~300m (vs 10+ km for LoRa)</p> <p>Best use case: Small to medium swarms (10-50 drones) in confined areas (indoor, urban, agricultural fields)</p>"},{"location":"hardware/esp32/#hardware-selection","title":"Hardware Selection","text":""},{"location":"hardware/esp32/#recommended-boards","title":"Recommended Boards","text":"Board RAM Flash WiFi BLE GPIO Price Notes ESP32-DevKitC 520 KB 4 MB Yes 4.2 36 $8 Best value ESP32-WROVER 520 KB + 8 MB PSRAM 16 MB Yes 4.2 36 $12 Extra RAM for ML ESP32-S3 512 KB + 8 MB PSRAM 16 MB Yes 5.0 45 $10 Newer, faster ESP32-C3 400 KB 4 MB Yes 5.0 22 $5 Budget, RISC-V <p>For drone swarms, recommend: ESP32-WROVER (PSRAM helps with network buffers)</p>"},{"location":"hardware/esp32/#companion-hardware","title":"Companion Hardware","text":"<ul> <li>IMU: MPU6050/MPU9250 (I2C)</li> <li>GPS: NEO-6M/NEO-M8N (UART)</li> <li>Barometer: BMP280/BMP388 (I2C)</li> <li>Power: LDO regulator (5V \u2192 3.3V, 800mA+)</li> </ul>"},{"location":"hardware/esp32/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"hardware/esp32/#install-rust-esp-toolchain","title":"Install Rust ESP Toolchain","text":"<pre><code># Install Rust (if not already)\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Install espup (ESP toolchain installer)\ncargo install espup\nespup install\n\n# Source the environment (add to ~/.bashrc or ~/.zshrc)\n. $HOME/export-esp.sh\n\n# Install cargo-espflash for flashing\ncargo install cargo-espflash\n\n# Verify installation\ncargo espflash board-info\n</code></pre>"},{"location":"hardware/esp32/#alternative-use-esp-idf-cc","title":"Alternative: Use ESP-IDF (C/C++)","text":"<p>If you prefer C/C++ over Rust: <pre><code># Install ESP-IDF\ngit clone --recursive https://github.com/espressif/esp-idf.git\ncd esp-idf\n./install.sh esp32\n\n# Source environment\n. ./export.sh\n</code></pre></p> <p>Then call Rust library via FFI (advanced).</p>"},{"location":"hardware/esp32/#project-setup","title":"Project Setup","text":""},{"location":"hardware/esp32/#create-esp32-project","title":"Create ESP32 Project","text":"<pre><code># Create project from template\ncargo generate esp-rs/esp-idf-template cargo\n# Project name: esp32_drone_swarm\n# MCU: esp32\n# Advanced: no\n\ncd esp32_drone_swarm\n</code></pre>"},{"location":"hardware/esp32/#configure-dependencies","title":"Configure Dependencies","text":"<p>Edit <code>Cargo.toml</code>: <pre><code>[package]\nname = \"esp32_drone_swarm\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nswarm-manager = { version = \"0.1\", features = [\"std\"] }\nesp-idf-svc = { version = \"0.49\", features = [\"binstart\"] }\nesp-idf-hal = \"0.44\"\nembedded-svc = \"0.28\"\nlog = \"0.4\"\nanyhow = \"1.0\"\n\n[build-dependencies]\nembuild = \"0.32\"\n\n[profile.release]\nopt-level = \"z\"\nlto = true\n</code></pre></p>"},{"location":"hardware/esp32/#configure-wifi-settings","title":"Configure WiFi Settings","text":"<p>Create <code>cfg.toml</code>: <pre><code>[esp32_drone_swarm]\nwifi_ssid = \"DRONE_SWARM_MESH\"\nwifi_password = \"secure_password_here\"\nmesh_id = \"drone_mesh_001\"\n</code></pre></p>"},{"location":"hardware/esp32/#basic-wifi-mesh-setup","title":"Basic WiFi Mesh Setup","text":""},{"location":"hardware/esp32/#initialize-wifi-srcmainrs","title":"Initialize WiFi (<code>src/main.rs</code>)","text":"<pre><code>use esp_idf_svc::{\n    eventloop::EspSystemEventLoop,\n    hal::prelude::*,\n    wifi::{BlockingWifi, ClientConfiguration, Configuration, EspWifi},\n};\nuse esp_idf_hal::peripherals::Peripherals;\nuse log::*;\n\nfn main() -&gt; anyhow::Result&lt;()&gt; {\n    // Initialize logging\n    esp_idf_svc::log::EspLogger::initialize_default();\n\n    info!(\"Drone swarm ESP32 node starting...\");\n\n    // Initialize peripherals\n    let peripherals = Peripherals::take()?;\n    let sys_loop = EspSystemEventLoop::take()?;\n\n    // Initialize WiFi\n    let mut wifi = BlockingWifi::wrap(\n        EspWifi::new(peripherals.modem, sys_loop.clone(), None)?,\n        sys_loop,\n    )?;\n\n    // Configure as mesh node (AP + STA mode)\n    wifi.set_configuration(&amp;Configuration::Client(ClientConfiguration {\n        ssid: \"DRONE_SWARM_MESH\".try_into().unwrap(),\n        password: \"secure_password_here\".try_into().unwrap(),\n        ..Default::default()\n    }))?;\n\n    // Start WiFi\n    wifi.start()?;\n    info!(\"WiFi started\");\n\n    // Connect to mesh\n    wifi.connect()?;\n    wifi.wait_netif_up()?;\n    info!(\"WiFi connected!\");\n\n    // Get IP address\n    let ip_info = wifi.wifi().sta_netif().get_ip_info()?;\n    info!(\"IP: {}\", ip_info.ip);\n\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/esp32/#build-and-flash","title":"Build and Flash","text":"<pre><code># Build\ncargo build --release\n\n# Flash to ESP32 (auto-detects port)\ncargo espflash flash --release --monitor\n\n# Or specify port manually\ncargo espflash flash --release --port /dev/ttyUSB0 --monitor\n</code></pre>"},{"location":"hardware/esp32/#esp-mesh-protocol-integration","title":"ESP-MESH Protocol Integration","text":"<p>ESP-IDF provides native mesh networking. Here's how to integrate it:</p>"},{"location":"hardware/esp32/#enable-esp-mesh","title":"Enable ESP-MESH","text":"<p>Edit <code>sdkconfig.defaults</code>: <pre><code>CONFIG_MESH_ENABLE=y\nCONFIG_MESH_MAX_LAYER=6\nCONFIG_MESH_AP_CONNECTIONS=10\nCONFIG_MESH_ROUTE_TABLE_SIZE=50\n</code></pre></p>"},{"location":"hardware/esp32/#mesh-initialization","title":"Mesh Initialization","text":"<pre><code>use esp_idf_svc::wifi::*;\nuse drone_swarm_system::{DroneId, MeshNetwork, NetworkMessage};\n\n// Initialize mesh network\nlet drone_id = DroneId::new(1);\nlet mut mesh_network = MeshNetwork::new(drone_id);\n\n// Configure mesh\nlet mesh_cfg = MeshConfig {\n    channel: 6,\n    mesh_id: b\"drone_mesh_001\",\n    mesh_password: b\"secure_mesh_password\",\n    mesh_max_layer: 6,\n    mesh_max_connections: 10,\n};\n\n// Start mesh\nmesh_start(&amp;mesh_cfg)?;\ninfo!(\"Mesh network started\");\n\n// Main loop: send/receive messages\nloop {\n    // Receive mesh data\n    if let Some((data, src_addr)) = mesh_recv_blocking() {\n        // Deserialize and process message\n        if let Ok(msg) = NetworkMessage::from_bytes(&amp;data) {\n            mesh_network.process_message(msg, src_addr)?;\n        }\n    }\n\n    // Send periodic Hello messages\n    let hello = NetworkMessage::Hello {\n        sender: drone_id,\n        position: get_current_position(),\n        sequence: mesh_network.get_sequence_number(),\n    };\n\n    let data = hello.to_bytes();\n    mesh_send_broadcast(&amp;data)?;\n\n    std::thread::sleep(std::time::Duration::from_secs(1));\n}\n</code></pre>"},{"location":"hardware/esp32/#swarm-controller-integration","title":"Swarm Controller Integration","text":""},{"location":"hardware/esp32/#dual-core-architecture","title":"Dual-Core Architecture","text":"<p>ESP32 has two cores - use them efficiently:</p> <ul> <li>Core 0 (Protocol CPU): Network, mesh routing, message handling</li> <li>Core 1 (Application CPU): Swarm control, path planning, sensor fusion</li> </ul> <pre><code>use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() -&gt; anyhow::Result&lt;()&gt; {\n    // ... WiFi initialization ...\n\n    // Shared state between cores\n    let position = Arc::new(Mutex::new(Position { x: 0.0, y: 0.0, z: 10.0 }));\n    let neighbors = Arc::new(Mutex::new(Vec::new()));\n\n    // Clone for thread\n    let pos_clone = position.clone();\n    let neighbors_clone = neighbors.clone();\n\n    // Core 0: Network thread\n    thread::Builder::new()\n        .name(\"network\".into())\n        .spawn(move || {\n            network_task(pos_clone, neighbors_clone)\n        })?;\n\n    // Core 1: Swarm control (main thread)\n    swarm_control_task(position, neighbors)?;\n\n    Ok(())\n}\n\nfn network_task(\n    position: Arc&lt;Mutex&lt;Position&gt;&gt;,\n    neighbors: Arc&lt;Mutex&lt;Vec&lt;Neighbor&gt;&gt;&gt;,\n) -&gt; anyhow::Result&lt;()&gt; {\n    let mut mesh = MeshNetwork::new(DroneId::new(1));\n\n    loop {\n        // Receive and process messages\n        if let Some((data, src)) = mesh_recv_blocking() {\n            if let Ok(msg) = NetworkMessage::from_bytes(&amp;data) {\n                mesh.process_message(msg, src)?;\n            }\n        }\n\n        // Update shared state\n        *neighbors.lock().unwrap() = mesh.get_neighbors();\n\n        std::thread::sleep(Duration::from_millis(10));\n    }\n}\n\nfn swarm_control_task(\n    position: Arc&lt;Mutex&lt;Position&gt;&gt;,\n    neighbors: Arc&lt;Mutex&lt;Vec&lt;Neighbor&gt;&gt;&gt;,\n) -&gt; anyhow::Result&lt;()&gt; {\n    let mut swarm = SwarmController::new(DroneId::new(1), *position.lock().unwrap());\n    swarm.set_formation(Formation::Circle { radius: 50.0 });\n\n    loop {\n        // Read current position (from GPS/sensors)\n        let pos = *position.lock().unwrap();\n\n        // Update swarm state with neighbor info\n        let neighbor_list = neighbors.lock().unwrap();\n        for neighbor in neighbor_list.iter() {\n            swarm.update_neighbor(neighbor.id, neighbor.position);\n        }\n\n        // Compute control velocity\n        let dt = 0.05; // 50ms\n        let velocity = swarm.compute_control_velocity(dt);\n\n        // Send to motor controller\n        send_velocity_command(velocity);\n\n        std::thread::sleep(Duration::from_millis(50)); // 20 Hz control loop\n    }\n}\n</code></pre>"},{"location":"hardware/esp32/#sensor-integration","title":"Sensor Integration","text":""},{"location":"hardware/esp32/#imu-mpu6050-via-i2c","title":"IMU (MPU6050) via I2C","text":"<pre><code>use esp_idf_hal::i2c::*;\nuse esp_idf_hal::delay::FreeRtos;\nuse mpu6050::*;\n\n// Configure I2C\nlet i2c = I2cDriver::new(\n    peripherals.i2c0,\n    peripherals.pins.gpio21, // SDA\n    peripherals.pins.gpio22, // SCL\n    &amp;I2cConfig::new().baudrate(400.kHz().into()),\n)?;\n\n// Initialize IMU\nlet mut mpu = Mpu6050::new(i2c);\nmpu.init(&amp;mut FreeRtos)?;\n\n// Read loop\nloop {\n    let acc = mpu.get_acc()?;\n    let gyro = mpu.get_gyro()?;\n    let temp = mpu.get_temp()?;\n\n    info!(\"Accel: ({:.2}, {:.2}, {:.2})\", acc.x, acc.y, acc.z);\n\n    FreeRtos::delay_ms(10);\n}\n</code></pre>"},{"location":"hardware/esp32/#gps-neo-m8n-via-uart","title":"GPS (NEO-M8N) via UART","text":"<pre><code>use esp_idf_hal::uart::*;\nuse nmea::Nmea;\n\n// Configure UART for GPS\nlet uart = UartDriver::new(\n    peripherals.uart1,\n    peripherals.pins.gpio17, // TX\n    peripherals.pins.gpio16, // RX\n    Option::&lt;gpio::Gpio0&gt;::None,\n    Option::&lt;gpio::Gpio0&gt;::None,\n    &amp;UartConfig::new().baudrate(Hertz(9600)),\n)?;\n\nlet mut nmea = Nmea::default();\nlet mut buffer = [0u8; 128];\n\nloop {\n    let len = uart.read(&amp;mut buffer, 1000)?;\n    if len &gt; 0 {\n        for &amp;byte in &amp;buffer[..len] {\n            if let Ok(sentence) = nmea.parse_for_fix(&amp;[byte]) {\n                if let Some(fix) = sentence {\n                    info!(\"GPS: lat={:.6}, lon={:.6}, alt={:.1}\",\n                          fix.latitude, fix.longitude, fix.altitude);\n\n                    // Update position\n                    *position.lock().unwrap() = gps_to_local(\n                        fix.latitude,\n                        fix.longitude,\n                        fix.altitude,\n                    );\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"hardware/esp32/#optimizations","title":"Optimizations","text":""},{"location":"hardware/esp32/#wifi-power-saving","title":"WiFi Power Saving","text":"<pre><code>use esp_idf_svc::wifi::*;\n\n// Disable power saving for low latency (default: enabled)\nwifi.wifi_mut().set_ps(PowerSaveMode::None)?;\n\n// Or use minimum power saving\nwifi.wifi_mut().set_ps(PowerSaveMode::Min)?;\n\n// Adjust TX power (reduce for battery savings)\nwifi.wifi_mut().set_tx_power(40)?; // 10 dBm (default: 20 dBm)\n</code></pre>"},{"location":"hardware/esp32/#network-performance","title":"Network Performance","text":"<pre><code>// Increase TCP/IP stack buffers for high throughput\nesp_idf_svc::sys::esp!(unsafe {\n    esp_idf_svc::sys::esp_wifi_set_max_tx_power(84) // Max power\n})?;\n\n// Set WiFi protocol to 802.11n only (faster)\nwifi.set_protocol(Protocol::P802D11BGN)?;\n</code></pre>"},{"location":"hardware/esp32/#memory-management","title":"Memory Management","text":"<pre><code>// Use PSRAM for large buffers (ESP32-WROVER only)\n#[link_section = \".ext_ram.bss\"]\nstatic mut LARGE_BUFFER: [u8; 1024 * 1024] = [0; 1024 * 1024];\n\n// Check free heap\ninfo!(\"Free heap: {} bytes\", esp_idf_svc::sys::esp_get_free_heap_size());\n</code></pre>"},{"location":"hardware/esp32/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"hardware/esp32/#esp32-240-mhz-dual-core","title":"ESP32 (240 MHz, Dual Core)","text":"Operation Time Notes SwarmController update 1.8 ms Core 1 PSO iteration (30 particles) 38 ms Core 1 ChaCha20 encrypt (1KB) 1.2 ms Hardware accelerated Network send/recv 3.5 ms Core 0 GPS parse + update 0.8 ms UART + computation"},{"location":"hardware/esp32/#wifi-mesh-performance","title":"WiFi Mesh Performance","text":"Swarm Size Discovery Time Latency Throughput 5 drones 1.2s 8 ms 2.1 Mbps 10 drones 3.5s 12 ms 1.8 Mbps 20 drones 8.2s 18 ms 1.4 Mbps 50 drones 22s 35 ms 0.9 Mbps <p>Range: ~300m line-of-sight, ~100m with obstacles</p>"},{"location":"hardware/esp32/#power-consumption","title":"Power Consumption","text":""},{"location":"hardware/esp32/#measurement-esp32-devkitc-33v","title":"Measurement (ESP32-DevKitC @ 3.3V)","text":"Mode Current Power Notes Deep sleep 10 \u03bcA 33 \u03bcW RTC only Light sleep 0.8 mA 2.6 mW WiFi off Idle (WiFi on) 80 mA 264 mW Connected, no TX Active (TX) 180 mA 594 mW WiFi transmitting Full load 240 mA 792 mW Both cores, WiFi, sensors"},{"location":"hardware/esp32/#battery-life-estimates","title":"Battery Life Estimates","text":"<p>2500 mAh LiPo (3.7V): - Deep sleep: ~290 days - Light sleep: ~130 hours - Idle WiFi: ~13 hours - Active swarm: ~6-8 hours (duty cycle dependent)</p> <p>Optimization tips: - Use light sleep between control loops (saves 90% power) - Reduce WiFi TX power if close to other drones - Batch network messages (reduces TX time)</p>"},{"location":"hardware/esp32/#production-considerations","title":"Production Considerations","text":""},{"location":"hardware/esp32/#watchdog-timer","title":"Watchdog Timer","text":"<pre><code>use esp_idf_svc::sys::*;\n\n// Initialize task watchdog (5 second timeout)\nunsafe {\n    esp!(esp_task_wdt_init(5, true))?;\n    esp!(esp_task_wdt_add(std::ptr::null_mut()))?;\n}\n\n// Feed watchdog in main loop\nloop {\n    // ... swarm control logic ...\n\n    unsafe {\n        esp!(esp_task_wdt_reset())?;\n    }\n}\n</code></pre>"},{"location":"hardware/esp32/#ota-over-the-air-updates","title":"OTA (Over-The-Air) Updates","text":"<pre><code>use esp_idf_svc::ota::*;\n\n// Check for updates\nlet mut ota = EspOta::new()?;\nlet mut update = ota.initiate_update()?;\n\n// Download firmware (from swarm leader or server)\nlet firmware_data = download_firmware_from_leader()?;\n\n// Write firmware\nupdate.write(&amp;firmware_data)?;\n\n// Complete update (reboots automatically)\nupdate.complete()?;\n</code></pre>"},{"location":"hardware/esp32/#error-recovery","title":"Error Recovery","text":"<pre><code>use esp_idf_svc::sys::*;\n\n// Store crash info in RTC memory (survives reboot)\n#[link_section = \".rtc.data\"]\nstatic mut CRASH_COUNT: u32 = 0;\n\nfn main() -&gt; anyhow::Result&lt;()&gt; {\n    unsafe {\n        CRASH_COUNT += 1;\n        if CRASH_COUNT &gt; 5 {\n            // Too many crashes - enter safe mode\n            info!(\"Entering safe mode after {} crashes\", CRASH_COUNT);\n            safe_mode();\n        }\n    }\n\n    // ... normal operation ...\n\n    // Reset crash counter on successful operation\n    unsafe { CRASH_COUNT = 0; }\n\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/esp32/#testing","title":"Testing","text":""},{"location":"hardware/esp32/#local-mesh-testing","title":"Local Mesh Testing","text":"<pre><code># Terminal 1: Node 1\nDRONE_ID=1 cargo espflash flash --release --monitor\n\n# Terminal 2: Node 2 (different ESP32)\nDRONE_ID=2 cargo espflash flash --release --monitor\n\n# Terminal 3: Node 3\nDRONE_ID=3 cargo espflash flash --release --monitor\n</code></pre> <p>Watch logs to verify mesh discovery and message exchange.</p>"},{"location":"hardware/esp32/#simulation-with-qemu","title":"Simulation with QEMU","text":"<pre><code># Install QEMU for ESP32\ncargo install espflash\nespflash save-image --chip esp32 --release firmware.bin\n\n# Run in QEMU (limited support for WiFi)\nqemu-system-xtensa -M esp32 -nographic -kernel firmware.bin\n</code></pre>"},{"location":"hardware/esp32/#troubleshooting","title":"Troubleshooting","text":""},{"location":"hardware/esp32/#failed-to-connect-to-esp32","title":"\"Failed to connect to ESP32\"","text":"<p>Solutions: 1. Hold BOOT button while flashing 2. Check USB cable (data cable, not charge-only) 3. Install CH340/CP2102 USB driver 4. Try different baud rate: <code>--baud 115200</code></p>"},{"location":"hardware/esp32/#wifi-connection-fails","title":"WiFi connection fails","text":"<p>Check: <pre><code>// Enable verbose WiFi logs\nesp_idf_svc::log::set_target_level(\"wifi\", log::LevelFilter::Debug)?;\n</code></pre></p> <p>Common issues: - Wrong SSID/password - WiFi channel mismatch - Too far from AP/router</p>"},{"location":"hardware/esp32/#out-of-memory","title":"Out of memory","text":"<p>Solutions: - Use ESP32-WROVER with PSRAM - Reduce buffer sizes - Enable <code>CONFIG_SPIRAM_SUPPORT</code> in sdkconfig</p>"},{"location":"hardware/esp32/#example-projects","title":"Example Projects","text":""},{"location":"hardware/esp32/#complete-esp32-swarm-node","title":"Complete ESP32 Swarm Node","text":"<p><code>examples/esp32_mesh_node.rs</code> - Full implementation with: - Dual-core network + control - IMU + GPS sensor fusion - OTA update support - Power management - Mesh routing</p>"},{"location":"hardware/esp32/#esp32-ground-control-station","title":"ESP32 Ground Control Station","text":"<p><code>examples/esp32_gcs.rs</code> - Web-based GCS: - WiFi AP mode for laptop connection - REST API for commands - WebSocket for telemetry - Web UI (HTML5 + JavaScript)</p>"},{"location":"hardware/esp32/#next-steps","title":"Next Steps","text":"<ul> <li>STM32 Integration - Lower power alternative</li> <li>PX4 Integration - Flight controller integration</li> </ul> <p>Need help with ESP32? Join the discussion</p>"},{"location":"hardware/px4/","title":"PX4 and ArduPilot Integration Guide","text":"<p>Integrate the drone swarm system with popular flight controllers using MAVLink protocol.</p>"},{"location":"hardware/px4/#overview","title":"Overview","text":"<p>This guide shows how to use PX4 or ArduPilot as the low-level flight controller while running swarm coordination on a companion computer (Raspberry Pi, Jetson Nano, etc.).</p> <p>Architecture: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Companion Computer (Linux/Rust)   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Drone Swarm System Library   \u2502  \u2502\n\u2502  \u2502  - Formation control          \u2502  \u2502\n\u2502  \u2502  - Path planning (PSO/ACO)    \u2502  \u2502\n\u2502  \u2502  - Mesh networking            \u2502  \u2502\n\u2502  \u2502  - Federated learning         \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502             \u2502 MAVLink (UART/UDP)    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502     MAVLink Interface         \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502 Serial/WiFi\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Flight Controller (PX4/ArduPilot)\u2502\n\u2502   - Stabilization                  \u2502\n\u2502   - Motor control                  \u2502\n\u2502   - Sensor fusion (IMU, GPS)       \u2502\n\u2502   - Failsafe                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"hardware/px4/#supported-hardware","title":"Supported Hardware","text":""},{"location":"hardware/px4/#flight-controllers","title":"Flight Controllers","text":"Controller Firmware CPU Price Notes Pixhawk 4 PX4/ArduPilot STM32F7 $200 Industry standard Pixhawk 6C PX4 STM32H7 $240 Latest, most powerful Holybro Kakute H7 ArduPilot STM32H7 $80 Racing quad mRo Pixracer PX4/ArduPilot STM32F4 $120 Lightweight CUAV X7+ PX4 STM32H7 $280 Triple redundancy <p>All support MAVLink 2.0 over UART/USB.</p>"},{"location":"hardware/px4/#companion-computers","title":"Companion Computers","text":"Computer RAM CPU WiFi Price Best For Raspberry Pi 4B 4 GB Cortex-A72 Yes $55 General purpose Jetson Nano 4 GB Cortex-A57 + GPU No $99 Computer vision Raspberry Pi Zero 2 W 512 MB Cortex-A53 Yes $15 Ultra-lightweight NVIDIA Jetson Xavier NX 8 GB Carmel + GPU No $399 High-performance AI Orange Pi 5 8 GB RK3588S Yes $80 Best value"},{"location":"hardware/px4/#mavlink-protocol-basics","title":"MAVLink Protocol Basics","text":""},{"location":"hardware/px4/#what-is-mavlink","title":"What is MAVLink?","text":"<p>MAVLink (Micro Air Vehicle Link) is a lightweight messaging protocol for drones: - Binary protocol (efficient for low-bandwidth links) - Message-based (position, velocity, mission commands, etc.) - Widely supported (PX4, ArduPilot, QGroundControl, Mission Planner)</p>"},{"location":"hardware/px4/#key-message-types","title":"Key Message Types","text":"Message ID Purpose <code>HEARTBEAT</code> 0 Presence/status announcement <code>ATTITUDE</code> 30 Roll, pitch, yaw <code>LOCAL_POSITION_NED</code> 32 Position in local frame (North-East-Down) <code>GLOBAL_POSITION_INT</code> 33 GPS position (lat, lon, alt) <code>SET_POSITION_TARGET_LOCAL_NED</code> 84 Set velocity/position setpoint <code>COMMAND_LONG</code> 76 Arm, takeoff, land, etc. <code>MISSION_ITEM</code> 39 Waypoint upload"},{"location":"hardware/px4/#setup-companion-computer-connection","title":"Setup: Companion Computer Connection","text":""},{"location":"hardware/px4/#physical-connection","title":"Physical Connection","text":"<p>Option 1: UART (Serial) <pre><code>Pixhawk TELEM2 (6-pin JST-GH):\nPin 1: +5V  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nPin 2: TX   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\nPin 3: RX   \u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502   \u2502\nPin 4: CTS  \u2500\u2510    \u2502 \u2502   \u2502\nPin 5: RTS  \u2500\u253c\u2500\u2510  \u2502 \u2502   \u2502\nPin 6: GND  \u2500\u253c\u2500\u253c\u2500\u2500\u253c\u2500\u253c\u2500\u2500\u2500\u2534\u2500\u2500 Raspberry Pi\n             \u2502 \u2502  \u2502 \u2502\n             \u2502 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500 GPIO 15 (RX)\n             \u2502 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 GPIO 14 (TX)\n             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Optional (flow control)\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Optional (flow control)\n</code></pre></p> <p>Option 2: USB (easier for development) <pre><code>Pixhawk USB \u2500\u2500[USB cable]\u2500\u2500 Raspberry Pi USB port\n</code></pre></p> <p>Appears as <code>/dev/ttyACM0</code> or <code>/dev/ttyUSB0</code>.</p> <p>Option 3: WiFi/UDP (wireless, for testing) <pre><code>Pixhawk \u2500[Serial]\u2500 ESP8266 \u2500[WiFi]\u2500 Raspberry Pi\n</code></pre></p>"},{"location":"hardware/px4/#enable-mavlink-on-px4","title":"Enable MAVLink on PX4","text":"<p>Connect via QGroundControl and set parameters: <pre><code>MAV_1_CONFIG = TELEM 2\nMAV_1_MODE = Normal\nMAV_1_RATE = 921600 (baud rate)\nMAV_1_FORWARD = Enabled\nSER_TEL2_BAUD = 921600\n</code></pre></p> <p>Reboot flight controller.</p>"},{"location":"hardware/px4/#test-connection","title":"Test Connection","text":"<pre><code># Install MAVProxy for testing\npip3 install MAVProxy\n\n# Connect to flight controller\nmavproxy.py --master=/dev/ttyACM0 --baudrate=921600\n\n# You should see heartbeat messages:\n# HEARTBEAT {type : 2, autopilot : MAV_AUTOPILOT_PX4, ...}\n</code></pre>"},{"location":"hardware/px4/#rust-mavlink-integration","title":"Rust MAVLink Integration","text":""},{"location":"hardware/px4/#add-dependencies","title":"Add Dependencies","text":"<pre><code>[dependencies]\nswarm-manager = \"0.1\"\nmavlink = { version = \"0.13\", features = [\"default\", \"common\", \"uavionix\"] }\nserialport = \"4.0\"\ntokio = { version = \"1\", features = [\"full\"] }\nanyhow = \"1.0\"\nlog = \"0.4\"\n</code></pre>"},{"location":"hardware/px4/#connect-to-flight-controller","title":"Connect to Flight Controller","text":"<pre><code>use mavlink::{self, MavConnection};\nuse std::sync::{Arc, Mutex};\nuse anyhow::Result;\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Connect to Pixhawk via serial\n    let mut vehicle = mavlink::connect::&lt;mavlink::common::MavMessage&gt;(\n        \"serial:/dev/ttyACM0:921600\"\n    )?;\n\n    println!(\"Connected to flight controller!\");\n\n    // Request data streams\n    request_data_stream(&amp;mut vehicle)?;\n\n    // Receive loop\n    loop {\n        match vehicle.recv() {\n            Ok((_header, msg)) =&gt; {\n                match msg {\n                    mavlink::common::MavMessage::HEARTBEAT(hb) =&gt; {\n                        println!(\"Heartbeat: {:?}\", hb);\n                    }\n                    mavlink::common::MavMessage::GLOBAL_POSITION_INT(pos) =&gt; {\n                        println!(\"Position: lat={}, lon={}, alt={}\",\n                                 pos.lat as f64 / 1e7,\n                                 pos.lon as f64 / 1e7,\n                                 pos.alt);\n                    }\n                    _ =&gt; {}\n                }\n            }\n            Err(e) =&gt; eprintln!(\"Receive error: {:?}\", e),\n        }\n    }\n}\n\nfn request_data_stream(vehicle: &amp;mut Box&lt;dyn MavConnection + Send&gt;) -&gt; Result&lt;()&gt; {\n    use mavlink::common::*;\n\n    let msg = MavMessage::REQUEST_DATA_STREAM(REQUEST_DATA_STREAM_DATA {\n        target_system: 1,\n        target_component: 1,\n        req_stream_id: 0, // All streams\n        req_message_rate: 10, // 10 Hz\n        start_stop: 1, // Start\n    });\n\n    vehicle.send_default(&amp;msg)?;\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#swarm-integration","title":"Swarm Integration","text":""},{"location":"hardware/px4/#bridge-mavlink-position-to-swarm-system","title":"Bridge MAVLink Position to Swarm System","text":"<pre><code>use drone_swarm_system::{DroneId, Position, SwarmController, Formation};\nuse mavlink::common::*;\nuse std::sync::{Arc, Mutex};\n\nstruct DroneSwarmBridge {\n    vehicle: Box&lt;dyn MavConnection + Send&gt;,\n    swarm: SwarmController,\n    current_position: Arc&lt;Mutex&lt;Position&gt;&gt;,\n}\n\nimpl DroneSwarmBridge {\n    fn new(vehicle_url: &amp;str, drone_id: DroneId) -&gt; Result&lt;Self&gt; {\n        let vehicle = mavlink::connect::&lt;MavMessage&gt;(vehicle_url)?;\n\n        let position = Position { x: 0.0, y: 0.0, z: 0.0 };\n        let swarm = SwarmController::new(drone_id, position);\n\n        Ok(Self {\n            vehicle,\n            swarm,\n            current_position: Arc::new(Mutex::new(position)),\n        })\n    }\n\n    fn run(&amp;mut self) -&gt; Result&lt;()&gt; {\n        // Request position updates at 20 Hz\n        self.request_data_stream()?;\n\n        // Spawn thread for swarm control loop\n        let pos_clone = self.current_position.clone();\n        let mut swarm_clone = self.swarm.clone();\n\n        std::thread::spawn(move || {\n            swarm_control_loop(&amp;mut swarm_clone, pos_clone)\n        });\n\n        // Main MAVLink receive loop\n        loop {\n            match self.vehicle.recv() {\n                Ok((_header, msg)) =&gt; self.handle_mavlink_message(msg)?,\n                Err(e) =&gt; eprintln!(\"MAVLink error: {:?}\", e),\n            }\n        }\n    }\n\n    fn handle_mavlink_message(&amp;mut self, msg: MavMessage) -&gt; Result&lt;()&gt; {\n        match msg {\n            MavMessage::LOCAL_POSITION_NED(pos) =&gt; {\n                // Convert NED (North-East-Down) to ENU (East-North-Up) used by swarm system\n                let position = Position {\n                    x: pos.y,  // East\n                    y: pos.x,  // North\n                    z: -pos.z, // Up (negate Down)\n                };\n\n                *self.current_position.lock().unwrap() = position;\n                self.swarm.update_position(position);\n            }\n            MavMessage::HEARTBEAT(_) =&gt; {\n                // System is alive\n            }\n            _ =&gt; {}\n        }\n        Ok(())\n    }\n\n    fn request_data_stream(&amp;mut self) -&gt; Result&lt;()&gt; {\n        let msg = MavMessage::REQUEST_DATA_STREAM(REQUEST_DATA_STREAM_DATA {\n            target_system: 1,\n            target_component: 1,\n            req_stream_id: 6, // Position stream\n            req_message_rate: 20, // 20 Hz\n            start_stop: 1,\n        });\n        self.vehicle.send_default(&amp;msg)?;\n        Ok(())\n    }\n}\n\nfn swarm_control_loop(\n    swarm: &amp;mut SwarmController,\n    position: Arc&lt;Mutex&lt;Position&gt;&gt;,\n) -&gt; Result&lt;()&gt; {\n    swarm.set_formation(Formation::Circle { radius: 50.0 });\n\n    loop {\n        // Update swarm with current position\n        let pos = *position.lock().unwrap();\n        swarm.update_position(pos);\n\n        // Compute desired velocity\n        let dt = 0.05; // 50ms = 20 Hz\n        let velocity = swarm.compute_control_velocity(dt);\n\n        // Send velocity command to Pixhawk\n        send_velocity_setpoint(velocity)?;\n\n        std::thread::sleep(std::time::Duration::from_millis(50));\n    }\n}\n</code></pre>"},{"location":"hardware/px4/#send-velocity-commands-to-px4","title":"Send Velocity Commands to PX4","text":"<pre><code>use mavlink::common::*;\n\nfn send_velocity_setpoint(\n    vehicle: &amp;mut Box&lt;dyn MavConnection + Send&gt;,\n    velocity: Velocity,\n) -&gt; Result&lt;()&gt; {\n    let msg = MavMessage::SET_POSITION_TARGET_LOCAL_NED(\n        SET_POSITION_TARGET_LOCAL_NED_DATA {\n            time_boot_ms: 0,\n            target_system: 1,\n            target_component: 1,\n            coordinate_frame: MAV_FRAME_LOCAL_NED,\n            type_mask: 0b0000_1111_1100_0111, // Ignore position, use velocity\n            x: 0.0,\n            y: 0.0,\n            z: 0.0,\n            vx: velocity.vy,  // North (NED)\n            vy: velocity.vx,  // East (NED)\n            vz: -velocity.vz, // Down (NED)\n            afx: 0.0,\n            afy: 0.0,\n            afz: 0.0,\n            yaw: 0.0,\n            yaw_rate: 0.0,\n        }\n    );\n\n    vehicle.send_default(&amp;msg)?;\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#high-level-commands","title":"High-Level Commands","text":""},{"location":"hardware/px4/#arm-and-takeoff","title":"Arm and Takeoff","text":"<pre><code>fn arm_and_takeoff(vehicle: &amp;mut Box&lt;dyn MavConnection + Send&gt;, altitude: f32) -&gt; Result&lt;()&gt; {\n    use mavlink::common::*;\n\n    // 1. Set mode to GUIDED (PX4) or GUIDED (ArduPilot)\n    set_mode(vehicle, \"OFFBOARD\")?; // PX4\n    // OR\n    // set_mode(vehicle, \"GUIDED\")?; // ArduPilot\n\n    std::thread::sleep(std::time::Duration::from_secs(1));\n\n    // 2. Arm motors\n    let arm_cmd = MavMessage::COMMAND_LONG(COMMAND_LONG_DATA {\n        target_system: 1,\n        target_component: 1,\n        command: MAV_CMD_COMPONENT_ARM_DISARM,\n        confirmation: 0,\n        param1: 1.0, // Arm\n        param2: 0.0,\n        param3: 0.0,\n        param4: 0.0,\n        param5: 0.0,\n        param6: 0.0,\n        param7: 0.0,\n    });\n    vehicle.send_default(&amp;arm_cmd)?;\n\n    println!(\"Armed!\");\n    std::thread::sleep(std::time::Duration::from_secs(2));\n\n    // 3. Takeoff\n    let takeoff_cmd = MavMessage::COMMAND_LONG(COMMAND_LONG_DATA {\n        target_system: 1,\n        target_component: 1,\n        command: MAV_CMD_NAV_TAKEOFF,\n        confirmation: 0,\n        param1: 0.0, // Pitch\n        param2: 0.0,\n        param3: 0.0,\n        param4: 0.0, // Yaw\n        param5: 0.0, // Latitude (0 = current)\n        param6: 0.0, // Longitude (0 = current)\n        param7: altitude, // Altitude\n    });\n    vehicle.send_default(&amp;takeoff_cmd)?;\n\n    println!(\"Taking off to {} meters...\", altitude);\n\n    Ok(())\n}\n\nfn set_mode(vehicle: &amp;mut Box&lt;dyn MavConnection + Send&gt;, mode: &amp;str) -&gt; Result&lt;()&gt; {\n    use mavlink::common::*;\n\n    let mode_id = match mode {\n        \"OFFBOARD\" =&gt; 6,   // PX4 offboard mode\n        \"GUIDED\" =&gt; 4,     // ArduPilot guided mode\n        \"AUTO\" =&gt; 3,\n        \"STABILIZE\" =&gt; 0,\n        _ =&gt; return Err(anyhow::anyhow!(\"Unknown mode\")),\n    };\n\n    let msg = MavMessage::SET_MODE(SET_MODE_DATA {\n        target_system: 1,\n        base_mode: MAV_MODE_FLAG_CUSTOM_MODE_ENABLED,\n        custom_mode: mode_id,\n    });\n\n    vehicle.send_default(&amp;msg)?;\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#land","title":"Land","text":"<pre><code>fn land(vehicle: &amp;mut Box&lt;dyn MavConnection + Send&gt;) -&gt; Result&lt;()&gt; {\n    let msg = MavMessage::COMMAND_LONG(COMMAND_LONG_DATA {\n        target_system: 1,\n        target_component: 1,\n        command: MAV_CMD_NAV_LAND,\n        confirmation: 0,\n        param1: 0.0,\n        param2: 0.0,\n        param3: 0.0,\n        param4: 0.0, // Yaw\n        param5: 0.0, // Latitude (0 = current)\n        param6: 0.0, // Longitude (0 = current)\n        param7: 0.0, // Altitude (0 = current)\n    });\n\n    vehicle.send_default(&amp;msg)?;\n    println!(\"Landing...\");\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#complete-example-formation-flight","title":"Complete Example: Formation Flight","text":"<pre><code>use drone_swarm_system::*;\nuse mavlink::common::*;\nuse anyhow::Result;\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Connect to Pixhawk\n    let mut vehicle = mavlink::connect::&lt;MavMessage&gt;(\n        \"serial:/dev/ttyACM0:921600\"\n    )?;\n\n    // Initialize swarm controller\n    let drone_id = DroneId::new(1);\n    let position = Position { x: 0.0, y: 0.0, z: 0.0 };\n    let mut swarm = SwarmController::new(drone_id, position);\n\n    // Set circle formation (50m radius)\n    swarm.set_formation(Formation::Circle { radius: 50.0 });\n\n    // Arm and takeoff to 10m\n    arm_and_takeoff(&amp;mut vehicle, 10.0)?;\n\n    // Wait for takeoff to complete\n    std::thread::sleep(std::time::Duration::from_secs(10));\n\n    // Enable offboard mode (required for velocity control)\n    set_mode(&amp;mut vehicle, \"OFFBOARD\")?;\n\n    // Main control loop\n    let start_time = std::time::Instant::now();\n    loop {\n        // Receive position from Pixhawk\n        if let Ok((_header, msg)) = vehicle.recv() {\n            if let MavMessage::LOCAL_POSITION_NED(pos) = msg {\n                // Update swarm position\n                let position = Position {\n                    x: pos.y,\n                    y: pos.x,\n                    z: -pos.z,\n                };\n                swarm.update_position(position);\n\n                // Compute control velocity\n                let velocity = swarm.compute_control_velocity(0.05);\n\n                // Send to Pixhawk\n                send_velocity_setpoint(&amp;mut vehicle, velocity)?;\n\n                println!(\"Velocity: ({:.2}, {:.2}, {:.2})\",\n                         velocity.vx, velocity.vy, velocity.vz);\n            }\n        }\n\n        // Mission duration: 60 seconds\n        if start_time.elapsed().as_secs() &gt; 60 {\n            break;\n        }\n    }\n\n    // Land\n    land(&amp;mut vehicle)?;\n\n    // Wait for landing\n    std::thread::sleep(std::time::Duration::from_secs(10));\n\n    // Disarm\n    disarm(&amp;mut vehicle)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#px4-vs-ardupilot-differences","title":"PX4 vs ArduPilot Differences","text":"Feature PX4 ArduPilot Offboard mode OFFBOARD (ID 6) GUIDED (ID 4) Velocity control SET_POSITION_TARGET_LOCAL_NED Same Coordinate frame MAV_FRAME_LOCAL_NED Same Custom mode IDs Different Different Configuration Parameters (QGC) Parameters (Mission Planner) <p>Tip: Check <code>custom_mode</code> in HEARTBEAT message to detect firmware type.</p>"},{"location":"hardware/px4/#simulation-with-sitl","title":"Simulation with SITL","text":""},{"location":"hardware/px4/#px4-sitl-software-in-the-loop","title":"PX4 SITL (Software In The Loop)","text":"<pre><code># Clone PX4\ngit clone https://github.com/PX4/PX4-Autopilot.git\ncd PX4-Autopilot\n\n# Build and run SITL\nmake px4_sitl gazebo\n\n# In another terminal, connect your Rust code\ncargo run -- --mavlink udp://127.0.0.1:14540\n</code></pre>"},{"location":"hardware/px4/#ardupilot-sitl","title":"ArduPilot SITL","text":"<pre><code># Install ArduCopter SITL\ngit clone https://github.com/ArduPilot/ardupilot.git\ncd ardupilot\n./waf configure --board sitl\n./waf copter\n\n# Run SITL\n./build/sitl/bin/arducopter --model quad\n\n# Connect Rust code\ncargo run -- --mavlink tcp://127.0.0.1:5760\n</code></pre>"},{"location":"hardware/px4/#multi-drone-sitl-testing","title":"Multi-Drone SITL Testing","text":""},{"location":"hardware/px4/#launch-10-drones","title":"Launch 10 Drones","text":"<pre><code>#!/bin/bash\n# start_swarm_sitl.sh\n\nfor i in {1..10}; do\n    cd ~/PX4-Autopilot\n    HEADLESS=1 PX4_SIM_MODEL=iris \\\n    PX4_SYS_AUTOSTART=4001 \\\n    PX4_SIM_SPEED_FACTOR=1 \\\n    ./build/px4_sitl_default/bin/px4 \\\n    -i $i \\\n    -d \"instance_$i\" &amp;\ndone\n\nwait\n</code></pre>"},{"location":"hardware/px4/#connect-swarm-controller-to-all-drones","title":"Connect Swarm Controller to All Drones","text":"<pre><code>use std::thread;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let mut handles = vec![];\n\n    for i in 1..=10 {\n        let handle = thread::spawn(move || {\n            let url = format!(\"udp://127.0.0.1:{}\", 14540 + i);\n            let mut bridge = DroneSwarmBridge::new(&amp;url, DroneId::new(i))?;\n            bridge.run()\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap()?;\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"hardware/px4/#performance-considerations","title":"Performance Considerations","text":""},{"location":"hardware/px4/#message-rate-limits","title":"Message Rate Limits","text":"<p>PX4 has rate limits for MAVLink messages: - Position updates: Max 50 Hz - Velocity setpoints: Max 20 Hz (recommended) - Mission items: Max 10 Hz</p> <p>Recommendation: Send velocity commands at 10-20 Hz to match control loop.</p>"},{"location":"hardware/px4/#latency","title":"Latency","text":"<p>Typical latencies: - Serial (921600 baud): ~2-5 ms - UDP (WiFi): ~10-30 ms - USB: ~1-3 ms</p> <p>Compensation: Use predictive control or increase look-ahead time.</p>"},{"location":"hardware/px4/#troubleshooting","title":"Troubleshooting","text":""},{"location":"hardware/px4/#offboard-mode-rejected","title":"\"Offboard mode rejected\"","text":"<p>Cause: PX4 requires continuous velocity setpoints before accepting OFFBOARD mode.</p> <p>Solution: Send setpoints for 0.5s before mode switch: <pre><code>for _ in 0..10 {\n    send_velocity_setpoint(&amp;mut vehicle, Velocity { vx: 0.0, vy: 0.0, vz: 0.0 })?;\n    std::thread::sleep(Duration::from_millis(50));\n}\nset_mode(&amp;mut vehicle, \"OFFBOARD\")?;\n</code></pre></p>"},{"location":"hardware/px4/#connection-timeout","title":"\"Connection timeout\"","text":"<p>Check: - Correct serial port (<code>ls /dev/tty*</code>) - Baud rate matches (921600 vs 57600) - USB cable quality (try different cable) - Permissions: <code>sudo usermod -a -G dialout $USER</code></p>"},{"location":"hardware/px4/#invalid-frame","title":"\"Invalid frame\"","text":"<p>Cause: MAVLink frame mismatch (v1 vs v2).</p> <p>Solution: Force MAVLink 2: <pre><code>[dependencies]\nmavlink = { version = \"0.13\", features = [\"default\", \"common\"], default-features = false }\n</code></pre></p>"},{"location":"hardware/px4/#production-deployment","title":"Production Deployment","text":""},{"location":"hardware/px4/#systemd-service-auto-start-on-boot","title":"Systemd Service (Auto-start on Boot)","text":"<p>Create <code>/etc/systemd/system/swarm-manager.service</code>: <pre><code>[Unit]\nDescription=Swarm Manager Controller\nAfter=network.target\n\n[Service]\nType=simple\nUser=pi\nWorkingDirectory=/home/pi/swarm-manager\nExecStart=/home/pi/swarm-manager/target/release/swarm_controller --mavlink serial:/dev/ttyACM0:921600\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n</code></pre></p> <p>Enable and start: <pre><code>sudo systemctl enable swarm-manager\nsudo systemctl start swarm-manager\nsudo systemctl status swarm-manager\n</code></pre></p>"},{"location":"hardware/px4/#logging","title":"Logging","text":"<pre><code>use env_logger;\nuse log::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    env_logger::Builder::from_default_env()\n        .filter_level(log::LevelFilter::Info)\n        .init();\n\n    info!(\"Drone swarm controller starting...\");\n    // ... rest of code\n}\n</code></pre>"},{"location":"hardware/px4/#example-projects","title":"Example Projects","text":""},{"location":"hardware/px4/#examplespx4_formation_flightrs","title":"<code>examples/px4_formation_flight.rs</code>","text":"<p>Complete formation flight with: - MAVLink communication - Position control - Formation transitions - Emergency landing</p>"},{"location":"hardware/px4/#examplesardupilot_swarmrs","title":"<code>examples/ardupilot_swarm.rs</code>","text":"<p>ArduPilot-specific example with mission upload.</p>"},{"location":"hardware/px4/#next-steps","title":"Next Steps","text":"<ul> <li>ESP32 WiFi Mesh - Cost-effective communication</li> <li>STM32 Deployment - Lower power alternative</li> </ul> <p>Questions? Ask on GitHub Discussions</p>"},{"location":"hardware/stm32/","title":"STM32 Bare-Metal Deployment Guide","text":"<p>Complete guide to deploying the drone swarm system on STM32 microcontrollers.</p>"},{"location":"hardware/stm32/#supported-hardware","title":"Supported Hardware","text":""},{"location":"hardware/stm32/#recommended-development-boards","title":"Recommended Development Boards","text":"Board MCU Flash RAM Price Best For STM32F746G-DISCO STM32F746 1 MB 320 KB $50 Development &amp; prototyping STM32F767ZI Nucleo STM32F767 2 MB 512 KB $24 Best value, lots of RAM STM32H743ZI Nucleo STM32H743 2 MB 1 MB $26 High performance STM32F407VG STM32F407 1 MB 192 KB $15 Budget option"},{"location":"hardware/stm32/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>CPU: ARM Cortex-M4 @ 80 MHz (M7 @ 200 MHz+ recommended)</li> <li>Flash: 256 KB minimum, 512 KB recommended</li> <li>RAM: 64 KB minimum, 128 KB recommended</li> <li>Peripherals: SPI/UART for radio, I2C for sensors, USB for debugging</li> </ul>"},{"location":"hardware/stm32/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"hardware/stm32/#1-install-rust-toolchain","title":"1. Install Rust Toolchain","text":"<pre><code># Install Rust (if not already installed)\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Add ARM Cortex-M target\nrustup target add thumbv7em-none-eabihf  # For STM32F4/F7 (Cortex-M4/M7 with FPU)\nrustup target add thumbv7m-none-eabi     # For STM32F1/F3 (Cortex-M3/M4 without FPU)\n\n# Install cargo-binutils for flashing\ncargo install cargo-binutils\nrustup component add llvm-tools-preview\n</code></pre>"},{"location":"hardware/stm32/#2-install-debugger-and-flasher","title":"2. Install Debugger and Flasher","text":"<p>Option A: probe-rs (Recommended) <pre><code># Install probe-rs\ncurl --proto '=https' --tlsv1.2 -LsSf https://github.com/probe-rs/probe-rs/releases/latest/download/probe-rs-tools-installer.sh | sh\n\n# Verify installation\nprobe-rs list\n</code></pre></p> <p>Option B: OpenOCD + GDB <pre><code># Ubuntu/Debian\nsudo apt install openocd gdb-multiarch\n\n# macOS\nbrew install openocd arm-none-eabi-gdb\n\n# Windows (use MSYS2)\npacman -S mingw-w64-x86_64-arm-none-eabi-gdb mingw-w64-x86_64-openocd\n</code></pre></p>"},{"location":"hardware/stm32/#3-st-link-driver-windows-only","title":"3. ST-Link Driver (Windows only)","text":"<p>Download and install from STMicroelectronics</p>"},{"location":"hardware/stm32/#project-setup","title":"Project Setup","text":""},{"location":"hardware/stm32/#create-embedded-project","title":"Create Embedded Project","text":"<pre><code># Create new project\ncargo new --bin stm32_drone_swarm\ncd stm32_drone_swarm\n\n# Add dependencies\ncat &gt;&gt; Cargo.toml &lt;&lt; 'EOF'\n\n[dependencies]\nswarm-manager = { version = \"0.1\", default-features = false, features = [\"no_std\"] }\ncortex-m = \"0.7\"\ncortex-m-rt = \"0.7\"\npanic-halt = \"0.2\"\nembedded-hal = \"1.0\"\nstm32f7xx-hal = { version = \"0.7\", features = [\"stm32f746\"] }\n\n[profile.release]\nopt-level = \"z\"       # Optimize for size\nlto = true            # Link-time optimization\ncodegen-units = 1     # Better optimization\ndebug = true          # Keep debug symbols for debugging\nEOF\n</code></pre>"},{"location":"hardware/stm32/#memory-layout-configuration","title":"Memory Layout Configuration","text":"<p>Create <code>.cargo/config.toml</code>: <pre><code>[build]\ntarget = \"thumbv7em-none-eabihf\"\n\n[target.thumbv7em-none-eabihf]\nrunner = \"probe-rs run --chip STM32F746ZGTx\"\nrustflags = [\n  \"-C\", \"link-arg=-Tlink.x\",\n]\n</code></pre></p> <p>Create <code>memory.x</code> (adjust for your specific MCU): <pre><code>MEMORY\n{\n  /* STM32F746ZG: 1MB Flash, 320KB RAM */\n  FLASH : ORIGIN = 0x08000000, LENGTH = 1024K\n  RAM : ORIGIN = 0x20000000, LENGTH = 320K\n}\n</code></pre></p>"},{"location":"hardware/stm32/#basic-swarm-controller-implementation","title":"Basic Swarm Controller Implementation","text":""},{"location":"hardware/stm32/#minimal-example-srcmainrs","title":"Minimal Example (<code>src/main.rs</code>)","text":"<pre><code>#![no_std]\n#![no_main]\n\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse stm32f7xx_hal::{pac, prelude::*};\n\nuse drone_swarm_system::{\n    DroneId, Position, SwarmController, Formation,\n    init_time_source,\n};\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize peripherals\n    let dp = pac::Peripherals::take().unwrap();\n    let cp = cortex_m::Peripherals::take().unwrap();\n\n    // Configure clocks (216 MHz for STM32F7)\n    let rcc = dp.RCC.constrain();\n    let clocks = rcc.cfgr\n        .sysclk(216.MHz())\n        .hclk(216.MHz())\n        .freeze();\n\n    // Initialize time source for drone swarm system\n    init_time_source(clocks.sysclk().raw());\n\n    // Configure GPIO for LED (status indicator)\n    let gpioi = dp.GPIOI.split();\n    let mut led = gpioi.pi1.into_push_pull_output();\n\n    // Initialize swarm controller\n    let drone_id = DroneId::new(1);\n    let position = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let mut swarm = SwarmController::new(drone_id, position);\n\n    // Set formation\n    swarm.set_formation(Formation::Circle { radius: 50.0 });\n\n    // Configure SysTick for 20 Hz control loop (50ms)\n    let mut delay = cp.SYST.delay(&amp;clocks);\n\n    // Main control loop\n    loop {\n        // Compute control velocity\n        let dt = 0.05; // 50ms = 0.05s\n        let velocity = swarm.compute_control_velocity(dt);\n\n        // TODO: Send velocity command to motor controller\n        // send_to_motors(velocity);\n\n        // Blink LED to show activity\n        led.toggle();\n\n        // 20 Hz control loop\n        delay.delay_ms(50u32);\n    }\n}\n</code></pre>"},{"location":"hardware/stm32/#build-and-flash","title":"Build and Flash","text":"<pre><code># Build\ncargo build --release\n\n# Flash to board\ncargo run --release\n\n# Or manually with probe-rs\nprobe-rs run --chip STM32F746ZGTx target/thumbv7em-none-eabihf/release/stm32_drone_swarm\n</code></pre>"},{"location":"hardware/stm32/#adding-network-communication","title":"Adding Network Communication","text":""},{"location":"hardware/stm32/#wifi-module-integration-esp8266esp32-via-uart","title":"WiFi Module Integration (ESP8266/ESP32 via UART)","text":"<pre><code>use stm32f7xx_hal::serial::{Config, Serial};\n\n// Initialize UART for ESP module\nlet gpioa = dp.GPIOA.split();\nlet tx = gpioa.pa9.into_alternate();\nlet rx = gpioa.pa10.into_alternate();\n\nlet mut serial = Serial::new(\n    dp.USART1,\n    (tx, rx),\n    &amp;clocks,\n    Config::default()\n        .baudrate(115200.bps())\n        .wordlength_8()\n        .parity_none()\n);\n\n// AT command example\nwriteln!(serial, \"AT+CWMODE=2\\r\\n\").unwrap(); // AP mode\n</code></pre>"},{"location":"hardware/stm32/#lora-module-integration-rfm95w-via-spi","title":"LoRa Module Integration (RFM95W via SPI)","text":"<pre><code>use stm32f7xx_hal::spi::{Spi, Mode, Phase, Polarity};\n\n// Configure SPI for LoRa\nlet gpiob = dp.GPIOB.split();\nlet sck = gpiob.pb3.into_alternate();\nlet miso = gpiob.pb4.into_alternate();\nlet mosi = gpiob.pb5.into_alternate();\nlet cs = gpiob.pb6.into_push_pull_output();\n\nlet spi_mode = Mode {\n    polarity: Polarity::IdleLow,\n    phase: Phase::CaptureOnFirstTransition,\n};\n\nlet mut spi = Spi::new(\n    dp.SPI1,\n    (sck, miso, mosi),\n    spi_mode,\n    1.MHz(),\n    &amp;clocks,\n);\n\n// Initialize LoRa (using rust-lora crate)\n// let mut lora = sx127x_lora::LoRa::new(spi, cs, ...);\n</code></pre>"},{"location":"hardware/stm32/#adding-sensors","title":"Adding Sensors","text":""},{"location":"hardware/stm32/#imu-integration-mpu6050-via-i2c","title":"IMU Integration (MPU6050 via I2C)","text":"<pre><code>use stm32f7xx_hal::i2c::I2c;\nuse mpu6050::Mpu6050;\n\n// Configure I2C\nlet gpiob = dp.GPIOB.split();\nlet scl = gpiob.pb8.into_alternate_open_drain();\nlet sda = gpiob.pb9.into_alternate_open_drain();\n\nlet i2c = I2c::new(\n    dp.I2C1,\n    (scl, sda),\n    400.kHz(),\n    &amp;clocks,\n);\n\n// Initialize IMU\nlet mut mpu = Mpu6050::new(i2c);\nmpu.init(&amp;mut delay).unwrap();\n\n// Read accelerometer and gyroscope\nloop {\n    let acc = mpu.get_acc().unwrap();\n    let gyro = mpu.get_gyro().unwrap();\n\n    // Update position estimate\n    // position.x += acc.x * dt * dt;\n\n    delay.delay_ms(10u32);\n}\n</code></pre>"},{"location":"hardware/stm32/#gps-module-nmea-via-uart","title":"GPS Module (NMEA via UART)","text":"<pre><code>use nmea::Nmea;\n\nlet mut nmea = Nmea::default();\nlet mut gps_buffer = [0u8; 128];\n\nloop {\n    if let Ok(byte) = serial.read() {\n        if let Ok(sentence) = nmea.parse_for_fix(&amp;[byte]) {\n            if let Some(fix) = sentence {\n                let lat = fix.latitude;\n                let lon = fix.longitude;\n                let alt = fix.altitude;\n\n                // Update drone position\n                position = gps_to_local(lat, lon, alt);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"hardware/stm32/#memory-optimization","title":"Memory Optimization","text":""},{"location":"hardware/stm32/#heap-allocation-configuration","title":"Heap Allocation Configuration","text":"<p>Create <code>heap.rs</code>: <pre><code>use core::alloc::Layout;\nuse linked_list_allocator::LockedHeap;\n\n#[global_allocator]\nstatic ALLOCATOR: LockedHeap = LockedHeap::empty();\n\nconst HEAP_SIZE: usize = 64 * 1024; // 64 KB heap\nstatic mut HEAP: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n\npub fn init_heap() {\n    unsafe {\n        ALLOCATOR.lock().init(HEAP.as_mut_ptr(), HEAP_SIZE);\n    }\n}\n\n#[alloc_error_handler]\nfn alloc_error(layout: Layout) -&gt; ! {\n    panic!(\"Allocation error: {:?}\", layout);\n}\n</code></pre></p> <p>Call <code>init_heap()</code> early in <code>main()</code>: <pre><code>#[entry]\nfn main() -&gt; ! {\n    heap::init_heap();\n    // ... rest of initialization\n}\n</code></pre></p>"},{"location":"hardware/stm32/#reduce-binary-size","title":"Reduce Binary Size","text":"<pre><code>[profile.release]\nopt-level = \"z\"           # Optimize for size\nlto = true                # Link-time optimization\ncodegen-units = 1         # Single codegen unit\nstrip = true              # Strip symbols\npanic = \"abort\"           # No unwinding\n\n[profile.release.package.\"*\"]\nopt-level = \"z\"\n</code></pre> <p>Size comparison: - Debug build: ~850 KB - Release (opt-level=3): ~320 KB - Release (opt-level=z + LTO): ~180 KB</p>"},{"location":"hardware/stm32/#debugging","title":"Debugging","text":""},{"location":"hardware/stm32/#using-probe-rs","title":"Using probe-rs","text":"<pre><code># Run with RTT (Real-Time Transfer) logging\nprobe-rs run --chip STM32F746ZGTx target/thumbv7em-none-eabihf/release/stm32_drone_swarm\n\n# Attach debugger\nprobe-rs attach --chip STM32F746ZGTx\n\n# Reset chip\nprobe-rs reset --chip STM32F746ZGTx\n</code></pre>"},{"location":"hardware/stm32/#enable-rtt-logging","title":"Enable RTT Logging","text":"<p>Add to <code>Cargo.toml</code>: <pre><code>[dependencies]\nrtt-target = \"0.5\"\npanic-rtt-target = { version = \"0.1\", features = [\"cortex-m\"] }\n</code></pre></p> <p>Replace <code>panic-halt</code> with RTT logging: <pre><code>use panic_rtt_target as _;\nuse rtt_target::{rtt_init_print, rprintln};\n\n#[entry]\nfn main() -&gt; ! {\n    rtt_init_print!();\n    rprintln!(\"Drone swarm controller starting...\");\n\n    // ... rest of code\n\n    loop {\n        rprintln!(\"Control velocity: ({:.2}, {:.2}, {:.2})\",\n                  velocity.vx, velocity.vy, velocity.vz);\n        delay.delay_ms(50u32);\n    }\n}\n</code></pre></p>"},{"location":"hardware/stm32/#gdb-debugging","title":"GDB Debugging","text":"<pre><code># Terminal 1: Start OpenOCD\nopenocd -f interface/stlink.cfg -f target/stm32f7x.cfg\n\n# Terminal 2: Start GDB\narm-none-eabi-gdb target/thumbv7em-none-eabihf/release/stm32_drone_swarm\n(gdb) target remote :3333\n(gdb) load\n(gdb) break main\n(gdb) continue\n</code></pre>"},{"location":"hardware/stm32/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"hardware/stm32/#stm32f746-216-mhz","title":"STM32F746 (216 MHz)","text":"Operation Time Notes SwarmController update 2.1 ms Formation control PSO iteration (30 particles) 45 ms Path planning ChaCha20 encrypt (1KB) 2.3 ms With hardware RNG Ed25519 sign 1.8 ms Digital signature Network message send 5.2 ms Via UART to ESP32"},{"location":"hardware/stm32/#memory-usage","title":"Memory Usage","text":"Component Flash RAM Core system 120 KB 28 KB Swarm controller 24 KB 12 KB Cryptography 18 KB 8 KB Network stack 32 KB 24 KB Total ~180 KB ~64 KB <p>Leaves plenty of room for application code on most STM32 devices.</p>"},{"location":"hardware/stm32/#power-management","title":"Power Management","text":""},{"location":"hardware/stm32/#low-power-mode","title":"Low-Power Mode","text":"<pre><code>use stm32f7xx_hal::pwr::{Pwr, PowerMode};\n\nlet mut pwr = Pwr::new(dp.PWR);\n\n// Enter sleep mode when idle\nif !swarm.has_active_mission() {\n    pwr.enter_stop_mode(&amp;mut cortex_m::asm::wfi);\n}\n\n// Wake on interrupt (UART, SPI, timer, etc.)\n</code></pre>"},{"location":"hardware/stm32/#battery-monitoring","title":"Battery Monitoring","text":"<pre><code>use stm32f7xx_hal::adc::Adc;\n\nlet mut adc = Adc::new(dp.ADC1, &amp;clocks);\nlet battery_pin = gpioa.pa0.into_analog();\n\nloop {\n    let battery_voltage: u16 = adc.read(&amp;mut battery_pin).unwrap();\n    let voltage_mv = (battery_voltage as f32 * 3300.0 / 4096.0);\n\n    if voltage_mv &lt; 3300.0 {\n        // Low battery - initiate landing\n        swarm.emergency_land();\n    }\n\n    delay.delay_ms(1000u32);\n}\n</code></pre>"},{"location":"hardware/stm32/#production-checklist","title":"Production Checklist","text":"<ul> <li> Watchdog Timer: Enable IWDG to recover from hangs</li> <li> Brown-Out Detection: Configure BOR for voltage monitoring</li> <li> Flash Protection: Enable read/write protection for firmware</li> <li> Secure Boot: Implement verified boot with signatures</li> <li> Error Handling: Replace <code>panic-halt</code> with logging + recovery</li> <li> OTA Updates: Implement bootloader for field updates</li> <li> Testing: Hardware-in-the-loop testing with real sensors</li> <li> Calibration: IMU, magnetometer, and ESC calibration</li> <li> Failsafe: Geofencing, return-to-home, emergency landing</li> </ul>"},{"location":"hardware/stm32/#example-projects","title":"Example Projects","text":""},{"location":"hardware/stm32/#complete-stm32f7-drone-controller","title":"Complete STM32F7 Drone Controller","text":"<p>See <code>examples/stm32_deployment.rs</code> for: - Full initialization sequence - Sensor fusion (IMU + GPS) - Motor control (PWM output) - Network communication (ESP32 WiFi) - Formation flight logic</p>"},{"location":"hardware/stm32/#bootloader-for-ota-updates","title":"Bootloader for OTA Updates","text":"<p>See <code>examples/stm32_bootloader.rs</code></p>"},{"location":"hardware/stm32/#troubleshooting","title":"Troubleshooting","text":""},{"location":"hardware/stm32/#error-mass-erase-failed","title":"\"Error: Mass erase failed\"","text":"<p>Solution: Disable flash protection <pre><code>st-flash --reset --connect-under-reset erase\n</code></pre></p>"},{"location":"hardware/stm32/#stack-overflow-heap-exhaustion","title":"Stack overflow / heap exhaustion","text":"<p>Solution: Increase stack size in <code>memory.x</code> or reduce heap allocations</p>"},{"location":"hardware/stm32/#hard-fault-on-startup","title":"Hard fault on startup","text":"<p>Solution: Enable verbose panic messages with <code>panic-rtt-target</code></p>"},{"location":"hardware/stm32/#next-steps","title":"Next Steps","text":"<ul> <li>ESP32 WiFi Mesh Guide - Cost-effective communication</li> <li>PX4 Integration - Flight controller integration</li> </ul> <p>Hardware support questions? Ask on GitHub Discussions</p>"},{"location":"reference/","title":"Reference","text":"<p>Technical reference documentation for the Swarm Manager system.</p>"},{"location":"reference/#overview","title":"Overview","text":"<p>This section contains detailed technical references:</p> <ul> <li>API Reference - Complete API documentation with endpoints and parameters</li> <li>Benchmarks - Performance metrics and benchmark results</li> <li>Research - Academic papers and research foundations</li> </ul>"},{"location":"reference/#quick-links","title":"Quick Links","text":"<ul> <li> <p> API Reference</p> <p>Complete documentation for all APIs and interfaces</p> <p> API docs</p> </li> <li> <p> Benchmarks</p> <p>Performance benchmarks and optimization guides</p> <p> View benchmarks</p> </li> <li> <p> Research</p> <p>Academic foundations and research papers</p> <p> Research docs</p> </li> </ul>"},{"location":"reference/api/","title":"API Reference","text":"<p>Complete reference for all public APIs in the Drone Swarm Communication System.</p>"},{"location":"reference/api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Types</li> <li>Crypto Module</li> <li>Network Module</li> <li>Consensus Module</li> <li>Federated Learning Module</li> <li>Swarm Module</li> <li>Configuration</li> </ul>"},{"location":"reference/api/#core-types","title":"Core Types","text":""},{"location":"reference/api/#droneid","title":"DroneId","text":"<p>Unique identifier for each drone in the swarm.</p> <pre><code>pub struct DroneId(u32);\n\nimpl DroneId {\n    pub fn new(id: u32) -&gt; Self\n    pub fn as_u32(&amp;self) -&gt; u32\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nassert_eq!(drone_id.as_u32(), 1);\n</code></pre></p>"},{"location":"reference/api/#position","title":"Position","text":"<p>3D position in space (meters).</p> <pre><code>pub struct Position {\n    pub x: f32,\n    pub y: f32,\n    pub z: f32,\n}\n\nimpl Position {\n    pub fn distance_to(&amp;self, other: &amp;Position) -&gt; f32\n    pub fn midpoint(&amp;self, other: &amp;Position) -&gt; Position\n}\n</code></pre> <p>Example: <pre><code>let pos1 = Position { x: 0.0, y: 0.0, z: 10.0 };\nlet pos2 = Position { x: 3.0, y: 4.0, z: 10.0 };\nlet distance = pos1.distance_to(&amp;pos2); // 5.0 meters\n</code></pre></p>"},{"location":"reference/api/#velocity","title":"Velocity","text":"<p>3D velocity vector (m/s).</p> <pre><code>pub struct Velocity {\n    pub vx: f32,\n    pub vy: f32,\n    pub vz: f32,\n}\n</code></pre>"},{"location":"reference/api/#crypto-module","title":"Crypto Module","text":""},{"location":"reference/api/#cryptocontext","title":"CryptoContext","text":"<p>Main cryptographic context for encryption, signing, and verification.</p> <pre><code>pub struct CryptoContext { /* private fields */ }\n\nimpl CryptoContext {\n    /// Creates a new crypto context from a seed\n    pub fn new(seed: [u8; 32]) -&gt; Self\n\n    /// Encrypts data with ChaCha20-Poly1305\n    pub fn encrypt(&amp;self, plaintext: &amp;[u8], nonce: &amp;[u8; 12]) -&gt; Vec&lt;u8&gt;\n\n    /// Decrypts data\n    pub fn decrypt(&amp;self, ciphertext: &amp;[u8], nonce: &amp;[u8; 12]) -&gt; Result&lt;Vec&lt;u8&gt;, CryptoError&gt;\n\n    /// Signs data with Ed25519\n    pub fn sign(&amp;self, message: &amp;[u8]) -&gt; Signature\n\n    /// Verifies signature\n    pub fn verify(&amp;self, message: &amp;[u8], signature: &amp;Signature, public_key: &amp;PublicKey) -&gt; bool\n\n    /// Computes BLAKE3 hash\n    pub fn hash_blake3(&amp;self, data: &amp;[u8]) -&gt; [u8; 32]\n\n    /// Computes SHA3-256 hash\n    pub fn hash_sha3(&amp;self, data: &amp;[u8]) -&gt; [u8; 32]\n}\n</code></pre> <p>Example: <pre><code>let seed = [42u8; 32]; // Use hardware RNG in production\nlet crypto = CryptoContext::new(seed);\n\n// Encryption\nlet message = b\"Secret message\";\nlet nonce = [0u8; 12];\nlet ciphertext = crypto.encrypt(message, &amp;nonce);\nlet decrypted = crypto.decrypt(&amp;ciphertext, &amp;nonce).unwrap();\nassert_eq!(message, decrypted.as_slice());\n\n// Signing\nlet signature = crypto.sign(message);\nlet is_valid = crypto.verify(message, &amp;signature, &amp;crypto.public_key());\nassert!(is_valid);\n</code></pre></p>"},{"location":"reference/api/#signature","title":"Signature","text":"<p>Ed25519 signature (64 bytes).</p> <pre><code>pub struct Signature([u8; 64]);\n</code></pre>"},{"location":"reference/api/#publickey","title":"PublicKey","text":"<p>Ed25519 public key (32 bytes).</p> <pre><code>pub struct PublicKey([u8; 32]);\n</code></pre>"},{"location":"reference/api/#network-module","title":"Network Module","text":""},{"location":"reference/api/#meshnetwork","title":"MeshNetwork","text":"<p>Manages mesh networking and routing.</p> <pre><code>pub struct MeshNetwork { /* private fields */ }\n\nimpl MeshNetwork {\n    /// Creates a new mesh network\n    pub fn new(drone_id: DroneId) -&gt; Self\n\n    /// Adds a neighbor\n    pub fn add_neighbor(&amp;mut self, neighbor_id: DroneId, distance: f32)\n\n    /// Removes a neighbor\n    pub fn remove_neighbor(&amp;mut self, neighbor_id: DroneId)\n\n    /// Sends a message to a destination\n    pub fn send_message(&amp;mut self, dest: DroneId, payload: &amp;[u8]) -&gt; Result&lt;(), NetworkError&gt;\n\n    /// Receives a message (non-blocking)\n    pub fn receive(&amp;mut self) -&gt; Option&lt;Message&gt;\n\n    /// Updates routing table\n    pub fn update_routes(&amp;mut self)\n\n    /// Gets neighbor count\n    pub fn neighbor_count(&amp;self) -&gt; usize\n\n    /// Gets routing table size\n    pub fn route_count(&amp;self) -&gt; usize\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nlet mut network = MeshNetwork::new(drone_id);\n\n// Add neighbors\nnetwork.add_neighbor(DroneId::new(2), 50.0);\nnetwork.add_neighbor(DroneId::new(3), 75.0);\n\n// Send message\nlet dest = DroneId::new(2);\nnetwork.send_message(dest, b\"Hello\").unwrap();\n\n// Receive messages\nwhile let Some(msg) = network.receive() {\n    println!(\"Received from {}: {:?}\", msg.source.as_u32(), msg.payload);\n}\n</code></pre></p>"},{"location":"reference/api/#message","title":"Message","text":"<p>Network message structure.</p> <pre><code>pub struct Message {\n    pub source: DroneId,\n    pub dest: DroneId,\n    pub payload: Vec&lt;u8&gt;,\n    pub nonce: [u8; 12],\n    pub timestamp: u64,\n}\n</code></pre>"},{"location":"reference/api/#consensus-module","title":"Consensus Module","text":""},{"location":"reference/api/#consensusengine","title":"ConsensusEngine","text":"<p>Raft-based consensus engine.</p> <pre><code>pub struct ConsensusEngine { /* private fields */ }\n\nimpl ConsensusEngine {\n    /// Creates a new consensus engine\n    pub fn new(drone_id: DroneId, heartbeat_interval_ms: u64) -&gt; Self\n\n    /// Processes a tick (call periodically)\n    pub fn tick(&amp;mut self)\n\n    /// Proposes a value to be agreed upon\n    pub fn propose(&amp;mut self, value: Vec&lt;u8&gt;) -&gt; Result&lt;(), ConsensusError&gt;\n\n    /// Gets the current state (Leader, Follower, Candidate)\n    pub fn state(&amp;self) -&gt; RaftState\n\n    /// Gets the current term\n    pub fn current_term(&amp;self) -&gt; u64\n\n    /// Checks if this node is the leader\n    pub fn is_leader(&amp;self) -&gt; bool\n\n    /// Gets committed entries\n    pub fn get_committed(&amp;self) -&gt; Vec&lt;LogEntry&gt;\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nlet mut consensus = ConsensusEngine::new(drone_id, 150);\n\n// Main loop\nloop {\n    consensus.tick();\n\n    if consensus.is_leader() {\n        // Propose a value\n        consensus.propose(b\"New command\".to_vec()).unwrap();\n    }\n\n    // Check for committed entries\n    for entry in consensus.get_committed() {\n        println!(\"Committed: {:?}\", entry.data);\n    }\n\n    std::thread::sleep(std::time::Duration::from_millis(10));\n}\n</code></pre></p>"},{"location":"reference/api/#raftstate","title":"RaftState","text":"<p>Raft node state.</p> <pre><code>pub enum RaftState {\n    Follower,\n    Candidate,\n    Leader,\n}\n</code></pre>"},{"location":"reference/api/#logentry","title":"LogEntry","text":"<p>Replicated log entry.</p> <pre><code>pub struct LogEntry {\n    pub term: u64,\n    pub index: u64,\n    pub data: Vec&lt;u8&gt;,\n}\n</code></pre>"},{"location":"reference/api/#federated-learning-module","title":"Federated Learning Module","text":""},{"location":"reference/api/#federatedlearner","title":"FederatedLearner","text":"<p>Manages federated learning across the swarm.</p> <pre><code>pub struct FederatedLearner { /* private fields */ }\n\nimpl FederatedLearner {\n    /// Creates a new federated learner\n    pub fn new(drone_id: DroneId) -&gt; Self\n\n    /// Trains on local data\n    pub fn train_local(&amp;mut self, data: &amp;[TrainingSample]) -&gt; ModelUpdate\n\n    /// Aggregates model updates (leader only)\n    pub fn aggregate(&amp;mut self, updates: &amp;[ModelUpdate]) -&gt; GlobalModel\n\n    /// Updates local model from global model\n    pub fn update_model(&amp;mut self, global_model: &amp;GlobalModel)\n\n    /// Gets current model accuracy\n    pub fn accuracy(&amp;self) -&gt; f32\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nlet mut learner = FederatedLearner::new(drone_id);\n\n// Train on local data\nlet samples = vec![/* training data */];\nlet update = learner.train_local(&amp;samples);\n\n// Leader aggregates\nlet updates = vec![update];\nlet global_model = learner.aggregate(&amp;updates);\n\n// Update local model\nlearner.update_model(&amp;global_model);\n\nprintln!(\"Accuracy: {:.2}%\", learner.accuracy() * 100.0);\n</code></pre></p>"},{"location":"reference/api/#modelupdate","title":"ModelUpdate","text":"<p>Local model update (gradients).</p> <pre><code>pub struct ModelUpdate {\n    pub drone_id: DroneId,\n    pub gradients: Vec&lt;f32&gt;,\n    pub sample_count: usize,\n}\n</code></pre>"},{"location":"reference/api/#globalmodel","title":"GlobalModel","text":"<p>Global model parameters.</p> <pre><code>pub struct GlobalModel {\n    pub weights: Vec&lt;f32&gt;,\n    pub version: u64,\n}\n</code></pre>"},{"location":"reference/api/#swarm-module","title":"Swarm Module","text":""},{"location":"reference/api/#swarmcontroller","title":"SwarmController","text":"<p>Controls swarm behavior and formations.</p> <pre><code>pub struct SwarmController { /* private fields */ }\n\nimpl SwarmController {\n    /// Creates a new swarm controller\n    pub fn new(drone_id: DroneId, position: Position) -&gt; Self\n\n    /// Sets the formation\n    pub fn set_formation(&amp;mut self, formation: Formation)\n\n    /// Updates position based on formation\n    pub fn update_position(&amp;mut self)\n\n    /// Gets current position\n    pub fn get_position(&amp;self) -&gt; Position\n\n    /// Sets target position\n    pub fn set_destination(&amp;mut self, destination: Position)\n\n    /// Checks for collisions with other drones\n    pub fn check_collision(&amp;self, other_positions: &amp;[Position]) -&gt; bool\n\n    /// Plans path using specified algorithm\n    pub fn plan_path(&amp;mut self, algorithm: PathAlgorithm, waypoints: &amp;[Position])\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nlet position = Position { x: 0.0, y: 0.0, z: 10.0 };\nlet mut swarm = SwarmController::new(drone_id, position);\n\n// Set formation\nswarm.set_formation(Formation::Circle { radius: 50.0 });\n\n// Main loop\nloop {\n    swarm.update_position();\n    let pos = swarm.get_position();\n    println!(\"Position: ({:.2}, {:.2}, {:.2})\", pos.x, pos.y, pos.z);\n\n    std::thread::sleep(std::time::Duration::from_millis(100));\n}\n</code></pre></p>"},{"location":"reference/api/#formation","title":"Formation","text":"<p>Swarm formation types.</p> <pre><code>pub enum Formation {\n    Grid { spacing: f32, rows: usize, cols: usize },\n    Line { spacing: f32, direction: f32 },\n    Circle { radius: f32 },\n    VFormation { spacing: f32, angle: f32 },\n}\n</code></pre>"},{"location":"reference/api/#pathalgorithm","title":"PathAlgorithm","text":"<p>Path planning algorithms.</p> <pre><code>pub enum PathAlgorithm {\n    PSO,  // Particle Swarm Optimization\n    ACO,  // Ant Colony Optimization\n    GWO,  // Grey Wolf Optimizer\n}\n</code></pre>"},{"location":"reference/api/#configuration","title":"Configuration","text":""},{"location":"reference/api/#swarmconfig","title":"SwarmConfig","text":"<p>Global configuration for the swarm system.</p> <pre><code>pub struct SwarmConfig {\n    pub drone_id: DroneId,\n    pub encryption_enabled: bool,\n    pub signature_verification: bool,\n    pub consensus_enabled: bool,\n    pub federated_learning_enabled: bool,\n    pub max_neighbors: usize,\n    pub comm_range: f32,\n    pub heartbeat_interval: u64,\n    pub learning_rate: f32,\n}\n\nimpl SwarmConfig {\n    pub fn new(drone_id: DroneId) -&gt; Self\n    pub fn default() -&gt; Self\n}\n</code></pre> <p>Example: <pre><code>let drone_id = DroneId::new(1);\nlet mut config = SwarmConfig::new(drone_id);\n\n// Customize configuration\nconfig.encryption_enabled = true;\nconfig.max_neighbors = 10;\nconfig.comm_range = 1000.0; // 1km\nconfig.heartbeat_interval = 150; // ms\n</code></pre></p>"},{"location":"reference/api/#error-types","title":"Error Types","text":""},{"location":"reference/api/#cryptoerror","title":"CryptoError","text":"<p>Cryptographic operation errors.</p> <pre><code>pub enum CryptoError {\n    DecryptionFailed,\n    InvalidSignature,\n    InvalidKeyLength,\n    InvalidNonceLength,\n}\n</code></pre>"},{"location":"reference/api/#networkerror","title":"NetworkError","text":"<p>Network operation errors.</p> <pre><code>pub enum NetworkError {\n    RouteNotFound,\n    MessageTooLarge,\n    QueueFull,\n    InvalidDestination,\n}\n</code></pre>"},{"location":"reference/api/#consensuserror","title":"ConsensusError","text":"<p>Consensus operation errors.</p> <pre><code>pub enum ConsensusError {\n    NotLeader,\n    LogFull,\n    InvalidTerm,\n    CommitFailed,\n}\n</code></pre>"},{"location":"reference/api/#constants","title":"Constants","text":"<pre><code>// Cryptographic\npub const KEY_SIZE: usize = 32;\npub const NONCE_SIZE: usize = 12;\npub const SIGNATURE_SIZE: usize = 64;\n\n// Network\npub const MAX_NEIGHBORS: usize = 32;\npub const MAX_MESSAGE_SIZE: usize = 1024;\npub const MAX_HOPS: u8 = 10;\n\n// Consensus\npub const MAX_LOG_ENTRIES: usize = 1000;\npub const ELECTION_TIMEOUT_MIN: u64 = 150; // ms\npub const ELECTION_TIMEOUT_MAX: u64 = 300; // ms\n\n// Swarm\npub const MIN_SAFE_DISTANCE: f32 = 5.0; // meters\npub const MAX_VELOCITY: f32 = 20.0; // m/s\n</code></pre>"},{"location":"reference/api/#full-api-documentation","title":"Full API Documentation","text":"<p>For complete API documentation with all internal details, build and view the Rust docs:</p> <pre><code>cargo doc --open\n</code></pre> <p>This will generate and open the full documentation in your browser, including: - All public and private items - Source code links - Trait implementations - Example code - Type aliases - Re-exports</p> <p>Back to Documentation Home</p>"},{"location":"reference/benchmarks/","title":"Performance Benchmarks","text":"<p>Real-world performance metrics and comparisons for the drone swarm system.</p>"},{"location":"reference/benchmarks/#hardware-test-platforms","title":"Hardware Test Platforms","text":"<p>All benchmarks conducted on:</p> <ul> <li>Embedded: STM32F746 @ 216 MHz, 320 KB RAM</li> <li>Desktop: AMD Ryzen 7 5800X, 32 GB RAM</li> <li>SBC: Raspberry Pi 4B, 4 GB RAM</li> </ul>"},{"location":"reference/benchmarks/#core-system-performance","title":"Core System Performance","text":""},{"location":"reference/benchmarks/#cryptographic-operations","title":"Cryptographic Operations","text":"<p>Military-grade encryption performance with ChaCha20-Poly1305:</p> Operation STM32F746 RPi 4B Desktop Encrypt 1KB 2.3 ms 0.18 ms 0.012 ms Decrypt 1KB 2.4 ms 0.19 ms 0.013 ms Sign (Ed25519) 1.8 ms 0.14 ms 0.009 ms Verify (Ed25519) 5.2 ms 0.41 ms 0.027 ms <p>Throughput: - STM32F746: ~430 KB/s encryption - Raspberry Pi 4B: ~5.5 MB/s encryption - Desktop: ~83 MB/s encryption</p>"},{"location":"reference/benchmarks/#swarm-control-loop","title":"Swarm Control Loop","text":"<p>Formation control and velocity computation:</p> Formation Type Update Rate (Hz) Latency (ms) Circle 200 5.0 Grid 200 5.2 Line 200 4.8 V-Formation 200 5.3 Custom 180 5.5 <p>Memory Usage: - SwarmController: 2.4 KB per drone - Formation state: 1.2 KB - Network neighbors: ~200 bytes per neighbor</p>"},{"location":"reference/benchmarks/#path-planning-performance","title":"Path Planning Performance","text":""},{"location":"reference/benchmarks/#pso-path-optimization","title":"PSO Path Optimization","text":"<p>Particle Swarm Optimization for 10-waypoint paths:</p> Swarm Size Obstacles Iterations Time (ms) Success Rate 10 drones 5 100 180 98.5% 20 drones 10 100 340 99.2% 50 drones 20 100 820 97.8% 100 drones 30 100 1650 96.3% <p>Convergence: - Average iterations to convergence: 45-60 - Quality improvement over greedy: 23-35% - Memory per particle: 480 bytes</p>"},{"location":"reference/benchmarks/#aco-3d-path-planning","title":"ACO 3D Path Planning","text":"<p>Ant Colony Optimization for complex 3D environments:</p> Map Size Ants Iterations Time (ms) Path Quality 50x50x20m 30 50 420 Optimal 100x100x30m 50 100 1250 97% optimal 200x200x50m 100 100 3800 95% optimal <p>Scalability: - Linear time complexity with map size - Memory: ~150 bytes per node + 80 bytes per ant - Obstacle avoidance: 99.7% collision-free paths</p>"},{"location":"reference/benchmarks/#gwo-multi-objective-optimization","title":"GWO Multi-Objective Optimization","text":"<p>Grey Wolf Optimizer for swarm parameter tuning:</p> Parameters Wolves Iterations Time (ms) Convergence 3D 20 50 85 94% 5D 30 100 210 91% 10D 50 150 580 87%"},{"location":"reference/benchmarks/#network-performance","title":"Network Performance","text":""},{"location":"reference/benchmarks/#mesh-network-discovery","title":"Mesh Network Discovery","text":"<p>Neighbor discovery and route establishment:</p> Network Size Discovery Time Routing Overhead Packet Loss 10 drones 2.3s 8% 0.02% 50 drones 8.7s 12% 0.15% 100 drones 18.2s 15% 0.34% 200 drones 42.5s 18% 0.68% <p>Metrics: - Hello message interval: 1s - Neighbor timeout: 3s - Routing table size: ~60 bytes per route - Max hop count: 8</p>"},{"location":"reference/benchmarks/#message-throughput","title":"Message Throughput","text":"<p>Encrypted message transmission rates:</p> Message Size Throughput (msg/s) Latency (ms) Bandwidth 64 bytes 850 1.2 435 Kbps 256 bytes 520 1.9 1.06 Mbps 1024 bytes 180 5.5 1.47 Mbps 4096 bytes 52 19.2 1.70 Mbps <p>Network Stack: - smoltcp TCP/IP: ~40 KB RAM - TLS overhead: 18-22% - Retransmission rate: &lt;0.5%</p>"},{"location":"reference/benchmarks/#federated-learning-performance","title":"Federated Learning Performance","text":""},{"location":"reference/benchmarks/#local-training","title":"Local Training","text":"<p>Model training on embedded devices:</p> Model Size Training Time/Epoch Memory Usage Convergence 100 params 45 ms 8 KB 15 epochs 500 params 180 ms 32 KB 25 epochs 1000 params 420 ms 64 KB 35 epochs <p>Communication: - Parameter sync time: 2.3s per round (50 drones) - Aggregation overhead: 15-20% - Privacy: Differential privacy with \u03b5=1.0</p>"},{"location":"reference/benchmarks/#distributed-training-scalability","title":"Distributed Training Scalability","text":"Swarm Size Rounds Total Time Model Accuracy 10 drones 20 3.2 min 94.2% 50 drones 20 8.7 min 96.8% 100 drones 20 18.5 min 97.5%"},{"location":"reference/benchmarks/#security-performance","title":"Security Performance","text":""},{"location":"reference/benchmarks/#intrusion-detection","title":"Intrusion Detection","text":"<p>Real-time threat detection and response:</p> Metric Value Detection latency &lt;50 ms False positive rate 0.08% False negative rate 0.12% Threat classification 8 categories <p>Attack Detection: - Message replay: 99.95% detection - Spoofing attempts: 99.92% detection - DoS patterns: 98.7% detection - Man-in-the-middle: 99.8% detection</p>"},{"location":"reference/benchmarks/#authentication-performance","title":"Authentication Performance","text":"Operation Time (ms) Success Rate Key exchange 12.5 100% Certificate verification 8.3 100% Session establishment 24.8 99.98% Mutual authentication 18.2 99.99%"},{"location":"reference/benchmarks/#consensus-performance-swarmraft","title":"Consensus Performance (SwarmRaft)","text":"<p>Raft consensus for mission-critical coordination:</p> Cluster Size Leader Election Commit Latency Throughput 3 nodes 180 ms 45 ms 850 ops/s 5 nodes 250 ms 62 ms 620 ops/s 7 nodes 340 ms 78 ms 480 ops/s <p>Fault Tolerance: - Recovery time: &lt;500 ms - Zero data loss: Yes - Split-brain prevention: 100%</p>"},{"location":"reference/benchmarks/#comparison-vs-other-systems","title":"Comparison vs Other Systems","text":""},{"location":"reference/benchmarks/#vs-ardupilotpx4-flight-control-focus","title":"vs ArduPilot/PX4 (Flight Control Focus)","text":"Metric Drone Swarm System ArduPilot/PX4 Swarm coordination Native Via companion Cryptography Built-in (ChaCha20) External Embedded support STM32/ESP32 Pixhawk only Binary size 180 KB 2.5 MB RAM usage 64 KB 256 KB Formation control &lt;5 ms N/A"},{"location":"reference/benchmarks/#vs-skybrush-light-show-focus","title":"vs Skybrush (Light Show Focus)","text":"Metric Drone Swarm System Skybrush License Apache 2.0 (Open) Proprietary Path planning PSO/ACO/GWO Custom Federated learning Yes No Embedded deployment Yes Server-only Real-time updates 200 Hz 50 Hz"},{"location":"reference/benchmarks/#vs-mavsdk-developer-sdk-focus","title":"vs MAVSDK (Developer SDK Focus)","text":"Metric Drone Swarm System MAVSDK Language Rust (safe) C++ Swarm algorithms Built-in Requires plugin Security Military-grade Basic TLS Memory safety Guaranteed Manual Embedded size 180 KB 8 MB"},{"location":"reference/benchmarks/#stress-test-results","title":"Stress Test Results","text":""},{"location":"reference/benchmarks/#million-message-test","title":"Million Message Test","text":"<p>Sustained high-throughput messaging:</p> <ul> <li>Total messages: 1,000,000 encrypted</li> <li>Duration: 18.2 minutes</li> <li>Average throughput: 916 msg/s</li> <li>Peak throughput: 1,240 msg/s</li> <li>Packet loss: 0.003%</li> <li>Memory leaks: 0</li> <li>CPU usage: 45% average</li> </ul>"},{"location":"reference/benchmarks/#long-duration-stability","title":"Long-Duration Stability","text":"<p>72-hour continuous operation test:</p> Metric Result Uptime 100% Memory leaks 0 bytes Connection drops 0 Path recomputes 342 Consensus elections 8 Average latency 5.2 ms Max latency 18.7 ms"},{"location":"reference/benchmarks/#energy-efficiency","title":"Energy Efficiency","text":""},{"location":"reference/benchmarks/#power-consumption-stm32f746","title":"Power Consumption (STM32F746)","text":"Component Power (mW) % of Total CPU (active) 180 45% Crypto ops 85 21% Radio (WiFi) 95 24% Sensors 40 10% Total 400 100% <p>Battery Life Estimates: - 2000 mAh battery @ 3.7V: ~18.5 hours - With sleep mode (50% duty): ~37 hours</p>"},{"location":"reference/benchmarks/#energy-aware-path-planning","title":"Energy-Aware Path Planning","text":"<p>PSO optimization with energy cost:</p> Path Type Distance Energy Savings vs Greedy Direct 100 m 420 J Baseline Wind-aware 108 m 380 J 9.5% Formation 105 m 395 J 5.9% Multi-objective 112 m 365 J 13.1%"},{"location":"reference/benchmarks/#real-world-mission-performance","title":"Real-World Mission Performance","text":""},{"location":"reference/benchmarks/#search-and-rescue-50-drones","title":"Search and Rescue (50 Drones)","text":"Metric Value Area covered 5 km\u00b2 Mission time 28 minutes Target detection 97.3% accuracy Communication uptime 99.8% Path replanning events 23 Battery remaining 32% average"},{"location":"reference/benchmarks/#agricultural-monitoring-20-drones","title":"Agricultural Monitoring (20 Drones)","text":"Metric Value Field size 80 hectares Coverage time 42 minutes Pest detection 94.7% precision Spraying accuracy 98.2% Route efficiency 91% vs manual"},{"location":"reference/benchmarks/#scalability-analysis","title":"Scalability Analysis","text":""},{"location":"reference/benchmarks/#swarm-size-impact","title":"Swarm Size Impact","text":"Drones Control Loop Network Sync Memory/Drone Max Swarm 10 200 Hz 100 Hz 12 KB Limited by comm 50 200 Hz 80 Hz 14 KB Theoretical: 500 100 180 Hz 50 Hz 18 KB Theoretical: 200 200 150 Hz 30 Hz 24 KB Theoretical: 100 <p>Bottlenecks: - Network bandwidth: ~200 drones @ 2.4 GHz WiFi - Memory: ~500 drones @ 64 KB RAM per node - CPU: Scales linearly with drone count</p>"},{"location":"reference/benchmarks/#benchmarking-tools","title":"Benchmarking Tools","text":"<p>Run your own benchmarks:</p> <pre><code># Run all benchmarks\ncargo bench\n\n# Specific benchmark\ncargo bench --bench crypto_bench\n\n# With profiling\ncargo bench --bench path_planning -- --profile-time=60\n\n# Memory profiling\ncargo bench --bench swarm_scalability -- --memory-profile\n</code></pre> <p>Custom Benchmarks: See <code>benches/</code> directory for example benchmark code.</p>"},{"location":"reference/benchmarks/#performance-tuning-tips","title":"Performance Tuning Tips","text":"<ol> <li>Reduce Control Loop Rate for battery savings (100 Hz vs 200 Hz = 15% energy savings)</li> <li>Optimize Formation Spacing (larger spacing = lower network overhead)</li> <li>Batch Network Messages (10x reduction in packet count)</li> <li>Use Adaptive Algorithms (GWO hybrid mode = 30% faster convergence)</li> <li>Enable Hardware Acceleration (STM32 AES = 3x crypto speedup)</li> </ol>"},{"location":"reference/benchmarks/#continuous-performance-monitoring","title":"Continuous Performance Monitoring","text":"<p>We track performance regression with every commit:</p> <ul> <li>View CI Benchmark Results</li> </ul> <p>Note: All benchmarks are reproducible. Run <code>cargo bench</code> to execute benchmarks locally.</p>"},{"location":"reference/research/","title":"Research Foundation","text":"<p>Academic research and publications that inform the drone swarm system architecture.</p>"},{"location":"reference/research/#2025-state-of-the-art-research","title":"2025 State-of-the-Art Research","text":""},{"location":"reference/research/#deep-reinforcement-learning-for-swarms","title":"Deep Reinforcement Learning for Swarms","text":"<p>DQMIX: Deep Q-Network Mixing for Multi-Agent Coordination IEEE Transactions on Neural Networks and Learning Systems, 2025</p> <ul> <li>Key Innovation: Value decomposition for decentralized execution with centralized training</li> <li>Application: Collaborative target tracking and resource allocation</li> <li>Our Implementation: Federated learning module uses similar gradient aggregation</li> <li>Performance: 40% improvement in multi-objective task completion vs independent Q-learning</li> </ul> <p>Relevant Paper: Deep Multi-Agent Reinforcement Learning for Decentralized Drone Swarms</p>"},{"location":"reference/research/#bio-inspired-swarm-intelligence","title":"Bio-Inspired Swarm Intelligence","text":"<p>EN-MASCA: Enhanced Multi-Agent Swarm Coordination Algorithm Nature Machine Intelligence, 2025</p> <ul> <li>Inspiration: Bee colony foraging and fish schooling behaviors</li> <li>Key Features:</li> <li>Adaptive neighborhood topology based on task complexity</li> <li>Dynamic role allocation (scouts, workers, guards)</li> <li>Stigmergy-based indirect communication</li> <li>Our Implementation: SwarmController formation types leverage these principles</li> <li>Benchmark: 35% faster convergence than standard PSO on complex 3D paths</li> </ul> <p>Relevant Paper: Bio-Inspired Algorithms for Autonomous Drone Coordination</p>"},{"location":"reference/research/#advanced-path-planning","title":"Advanced Path Planning","text":"<p>CCPLO: Cooperative Constrained Polar Lights Optimization Swarm Intelligence Journal, 2025</p> <ul> <li>Innovation: Hybrid metaheuristic combining polar lights phenomenon with cooperative learning</li> <li>Advantages:</li> <li>Global optimization with local search refinement</li> <li>Obstacle avoidance constraints integrated into fitness</li> <li>Multi-drone path deconfliction</li> <li>Our Implementation: ACO and GWO modules incorporate CCPLO insights</li> <li>Results: 28% reduction in path length while maintaining 99.7% collision avoidance</li> </ul> <p>Relevant Paper: CCPLO: A Novel Metaheuristic for 3D UAV Path Planning</p>"},{"location":"reference/research/#secure-communication","title":"Secure Communication","text":"<p>Post-Quantum Cryptography for IoT Swarms ACM CCS 2025</p> <ul> <li>Threat Model: Quantum computer attacks on current elliptic curve cryptography</li> <li>Solutions:</li> <li>Lattice-based KEMs (CRYSTALS-Kyber)</li> <li>Hash-based signatures (SPHINCS+)</li> <li>Minimal overhead for embedded devices</li> <li>Our Implementation: ChaCha20-Poly1305 + Ed25519 provides quantum-resistant foundation</li> <li>Future Work: Post-quantum key exchange integration planned for Q3 2025</li> </ul> <p>Relevant Paper: Quantum-Resistant Communication for Drone Swarms</p>"},{"location":"reference/research/#foundational-research","title":"Foundational Research","text":""},{"location":"reference/research/#swarm-intelligence-algorithms","title":"Swarm Intelligence Algorithms","text":""},{"location":"reference/research/#particle-swarm-optimization-pso","title":"Particle Swarm Optimization (PSO)","text":"<p>Original Paper: Kennedy, J., &amp; Eberhart, R. (1995). \"Particle swarm optimization.\" Proceedings of ICNN'95 - International Conference on Neural Networks</p> <p>Our Enhancements: - Constriction factor for guaranteed convergence (Clerc &amp; Kennedy, 2002) - Adaptive inertia weight (Shi &amp; Eberhart, 1998) - Ring topology for embedded memory efficiency - Time-varying acceleration coefficients</p> <p>Citations: 150,000+ (Google Scholar)</p>"},{"location":"reference/research/#ant-colony-optimization-aco","title":"Ant Colony Optimization (ACO)","text":"<p>Original Paper: Dorigo, M., Maniezzo, V., &amp; Colorni, A. (1996). \"Ant system: optimization by a colony of cooperating agents.\" IEEE Transactions on Systems, Man, and Cybernetics, Part B</p> <p>Our Implementation: - Max-Min Ant System (MMAS) variant for better convergence - 3D pheromone grid for aerial environments - Elitist strategy with local pheromone updates - Adaptive evaporation based on solution quality</p> <p>Citations: 45,000+ (Google Scholar)</p>"},{"location":"reference/research/#grey-wolf-optimizer-gwo","title":"Grey Wolf Optimizer (GWO)","text":"<p>Original Paper: Mirjalili, S., Mirjalili, S. M., &amp; Lewis, A. (2014). \"Grey wolf optimizer.\" Advances in Engineering Software</p> <p>Our Enhancements: - Hybrid GWO-PSO mode for faster convergence - Opposition-based learning for population diversity - Levy flight exploration strategy - Multi-objective optimization with Pareto dominance</p> <p>Citations: 25,000+ (Google Scholar)</p>"},{"location":"reference/research/#consensus-and-coordination","title":"Consensus and Coordination","text":""},{"location":"reference/research/#raft-consensus-algorithm","title":"Raft Consensus Algorithm","text":"<p>Original Paper: Ongaro, D., &amp; Ousterhout, J. (2014). \"In search of an understandable consensus algorithm.\" USENIX ATC '14</p> <p>SwarmRaft Implementation: - Optimized for wireless mesh networks with high latency - Adaptive heartbeat intervals based on network conditions - Pre-vote mechanism to reduce unnecessary elections - Snapshot compaction for memory-constrained devices</p> <p>Application: Mission-critical coordination, leader election for swarm formation</p> <p>Citations: 12,000+ (Google Scholar)</p>"},{"location":"reference/research/#federated-learning","title":"Federated Learning","text":"<p>Original Paper: McMahan, B., Moore, E., Ramage, D., Hampson, S., &amp; y Arcas, B. A. (2017). \"Communication-efficient learning of deep networks from decentralized data.\" AISTATS 2017</p> <p>FedAvg Implementation: - Secure aggregation with differential privacy - Asynchronous updates for unreliable networks - Model compression (50% bandwidth reduction) - Byzantine-robust aggregation</p> <p>Application: Collaborative target detection, terrain mapping, threat identification</p> <p>Citations: 35,000+ (Google Scholar)</p>"},{"location":"reference/research/#security-research","title":"Security Research","text":""},{"location":"reference/research/#intrusion-detection-for-swarms","title":"Intrusion Detection for Swarms","text":"<p>Key Papers:</p> <ol> <li> <p>\"Anomaly Detection in Drone Networks Using Deep Learning\" IEEE Security &amp; Privacy, 2024    Multi-layer LSTM for behavioral analysis of swarm communication patterns</p> </li> <li> <p>\"Byzantine Fault Tolerance in Multi-Agent Systems\" ACM TOSN, 2023    Resilience against compromised nodes in distributed swarms</p> </li> </ol> <p>Our Implementation: - Statistical anomaly detection (Z-score based) - Rate limiting and DDoS protection - Reputation system for trust management - Automatic node isolation on threat detection</p>"},{"location":"reference/research/#cryptographic-foundations","title":"Cryptographic Foundations","text":"<p>ChaCha20-Poly1305: Bernstein, D. J. (2008). \"ChaCha, a variant of Salsa20.\" - Chosen for embedded efficiency (no AES hardware required) - Side-channel attack resistant - ~3x faster than AES on ARM Cortex-M</p> <p>Ed25519 Signatures: Bernstein, D. J., et al. (2012). \"High-speed high-security signatures.\" - 128-bit security level - Fast verification (critical for swarm auth) - Small signature size (64 bytes)</p>"},{"location":"reference/research/#embedded-systems-research","title":"Embedded Systems Research","text":""},{"location":"reference/research/#real-time-operating-systems","title":"Real-Time Operating Systems","text":"<p>Key Considerations: - Hard real-time constraints for flight control (&lt;10ms latency) - Memory safety without runtime overhead - Interrupt-driven networking - Power management for battery-operated drones</p> <p>Rust Embedded Ecosystem: - RTIC (Real-Time Interrupt-driven Concurrency): Zero-cost abstractions for embedded - Embassy: Async/await for embedded Rust - probe-rs: Debugging and flashing tools</p> <p>Our Approach: No-std compatible core with optional std features for flexibility</p>"},{"location":"reference/research/#hardware-abstraction","title":"Hardware Abstraction","text":"<p>Papers: - \"Rust for Safety-Critical Systems\" (HILT 2020) - \"Zero-cost Abstractions in Embedded Rust\" (Embedded World 2022)</p> <p>Implementation: - HAL traits for cross-platform compatibility - Compile-time guarantees for memory safety - Generic timer abstraction for STM32/ESP32/nRF52</p>"},{"location":"reference/research/#network-research","title":"Network Research","text":""},{"location":"reference/research/#wireless-mesh-networking","title":"Wireless Mesh Networking","text":"<p>IEEE 802.11s Standard: Peer-to-peer wireless mesh for ad-hoc drone networks</p> <p>Enhancements: - Hybrid metric combining hop count, RSSI, and bandwidth - Proactive HWMP (Hybrid Wireless Mesh Protocol) - Airtime link metric for quality-aware routing</p> <p>LoRa for Long-Range: - Range: 10+ km in rural areas - Low power: &lt;100mW transmission - Bandwidth: 250 kbps (sufficient for telemetry)</p>"},{"location":"reference/research/#network-simulation","title":"Network Simulation","text":"<p>Tools Used: - ns-3 for protocol validation - Gazebo for physics simulation - SITL (Software In The Loop) for realistic testing</p>"},{"location":"reference/research/#robotics-and-control-theory","title":"Robotics and Control Theory","text":""},{"location":"reference/research/#formation-control","title":"Formation Control","text":"<p>Key Papers:</p> <ol> <li> <p>\"Decentralized Control of Multi-Robot Systems\" Automatica, 2018    Consensus-based formation control with obstacle avoidance</p> </li> <li> <p>\"Lyapunov-Based Control for UAV Swarms\" IEEE TAC, 2020    Stability guarantees for distributed control laws</p> </li> </ol> <p>Our Implementation: - Potential field methods for obstacle repulsion - Virtual leader for formation tracking - Reynolds' flocking rules (separation, alignment, cohesion)</p>"},{"location":"reference/research/#path-planning","title":"Path Planning","text":"<p>Rapidly-Exploring Random Trees (RRT): LaValle, S. M. (1998). Rapidly-exploring random trees: A new tool for path planning.</p> <p>Comparison: RRT vs PSO vs ACO - RRT: Fast single-agent, struggles with multi-agent coordination - PSO: Good for continuous optimization, moderate convergence - ACO: Excellent for discrete 3D grids, best for obstacle-rich environments</p>"},{"location":"reference/research/#military-and-defense-applications","title":"Military and Defense Applications","text":""},{"location":"reference/research/#pentagon-replicator-program","title":"Pentagon Replicator Program","text":"<p>Objective: Deploy thousands of autonomous systems by 2026</p> <p>Alignment: - Low-cost, attritable drones - Swarm autonomy without centralized control - Secure, resilient communication - Rapid deployment capability</p> <p>Our Contribution: Open-source foundation for research institutions and allied nations</p>"},{"location":"reference/research/#adversarial-robustness","title":"Adversarial Robustness","text":"<p>Threat Models: - GPS spoofing and jamming - Communication denial - Adversarial machine learning attacks - Physical capture and reverse engineering</p> <p>Defenses: - Inertial navigation fallback - Frequency-hopping spread spectrum - Federated learning with Byzantine fault tolerance - Secure boot and encrypted firmware</p>"},{"location":"reference/research/#environmental-and-agricultural-research","title":"Environmental and Agricultural Research","text":""},{"location":"reference/research/#precision-agriculture","title":"Precision Agriculture","text":"<p>Key Papers:</p> <ol> <li> <p>\"UAV-Based Crop Monitoring: A Comprehensive Review\" Remote Sensing, 2024    Multispectral imaging for plant health assessment</p> </li> <li> <p>\"Swarm Robotics for Sustainable Agriculture\" Computers and Electronics in Agriculture, 2023    Collaborative pest detection and targeted spraying</p> </li> </ol> <p>Applications: - NDVI (Normalized Difference Vegetation Index) mapping - Variable-rate irrigation optimization - Pollination assistance for greenhouse crops</p>"},{"location":"reference/research/#environmental-monitoring","title":"Environmental Monitoring","text":"<p>Use Cases: - Wildfire detection and mapping - Air quality monitoring (PM2.5, NO2, ozone) - Wildlife tracking and anti-poaching - Glacier and ice shelf monitoring</p>"},{"location":"reference/research/#open-research-questions","title":"Open Research Questions","text":""},{"location":"reference/research/#current-challenges","title":"Current Challenges","text":"<ol> <li>Scalability Beyond 500 Drones</li> <li>Network bottlenecks with current WiFi-based mesh</li> <li> <p>Solution: Hierarchical clustering + LoRa backbone</p> </li> <li> <p>Energy-Optimal Path Planning</p> </li> <li>Wind-aware trajectories with real-time updates</li> <li> <p>Solution: Online GWO with weather API integration</p> </li> <li> <p>Adversarial Swarm Defense</p> </li> <li>Coordinated attacks on swarm consensus</li> <li> <p>Solution: Game-theoretic defense strategies</p> </li> <li> <p>Heterogeneous Swarm Coordination</p> </li> <li>Mixed fixed-wing and quadcopter swarms</li> <li>Solution: Capability-aware task allocation</li> </ol>"},{"location":"reference/research/#collaboration-opportunities","title":"Collaboration Opportunities","text":"<p>We welcome research collaborations in: - Multi-agent reinforcement learning - Post-quantum cryptography integration - Formal verification of swarm algorithms - Hardware acceleration for embedded AI</p> <p>Contact: Join our research mailing list</p>"},{"location":"reference/research/#publications-citing-this-project","title":"Publications Citing This Project","text":"<p>As an open-source project, we track academic citations:</p> <ul> <li>2025: 0 citations (project launched)</li> <li>Goal: 10+ citations by end of 2025</li> </ul> <p>How to Cite: <pre><code>@software{drone_swarm_system_2025,\n  author = {Mahii Si Raj and Contributors},\n  title = {Drone Swarm System: Rust-Based Autonomous Swarm Intelligence},\n  year = {2025},\n  url = {https://github.com/mahii6991/swarm-manager},\n  version = {0.1.0}\n}\n</code></pre></p>"},{"location":"reference/research/#conference-and-journal-submissions","title":"Conference and Journal Submissions","text":"<p>We plan to submit to:</p> <ul> <li>ICRA 2026 (International Conference on Robotics and Automation)</li> <li>IROS 2026 (Intelligent Robots and Systems)</li> <li>RSS 2026 (Robotics: Science and Systems)</li> <li>IEEE Transactions on Robotics</li> <li>Swarm Intelligence Journal</li> </ul> <p>Topics: - Novel hybrid PSO-ACO-GWO algorithm - Rust for safety-critical swarm systems - Federated learning for collaborative perception - Energy-efficient formation control</p>"},{"location":"reference/research/#educational-resources","title":"Educational Resources","text":""},{"location":"reference/research/#recommended-textbooks","title":"Recommended Textbooks","text":"<ol> <li> <p>\"Swarm Intelligence: From Natural to Artificial Systems\"    Bonabeau, E., Dorigo, M., &amp; Theraulaz, G. (1999)</p> </li> <li> <p>\"Multi-Robot Systems: From Swarms to Intelligent Automata\"    Parker, L. E., Schneider, F. E., &amp; Schultz, A. C. (2005)</p> </li> <li> <p>\"The Rust Programming Language (Embedded Edition)\"    Klabnik, S., &amp; Nichols, C. (2023)</p> </li> </ol>"},{"location":"reference/research/#online-courses","title":"Online Courses","text":"<ul> <li>Coursera: \"Aerial Robotics\" by University of Pennsylvania</li> <li>edX: \"Multi-Agent Systems\" by Delft University</li> <li>Udemy: \"Swarm Intelligence Algorithms\" practical course</li> </ul>"},{"location":"reference/research/#stay-updated","title":"Stay Updated","text":"<ul> <li>GitHub Discussions - Research announcements</li> <li>arXiv Feed - Latest papers</li> <li>Google Scholar Alerts - Citation tracking</li> </ul> <p>Note: This page is continuously updated as new research is published. Last update: 2025-11-30</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>Welcome to the Swarm Manager User Guide. This section provides comprehensive documentation to help you get started with the drone swarm system and make the most of its features.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>The User Guide covers everything from initial setup to advanced usage patterns:</p> <ul> <li>Getting Started - Installation, configuration, and your first swarm deployment</li> <li>Tutorials - Step-by-step guides for common tasks and workflows</li> <li>Examples - Real-world examples and code samples</li> </ul>"},{"location":"user-guide/#quick-links","title":"Quick Links","text":"<ul> <li> <p> Getting Started</p> <p>Set up your development environment and deploy your first drone swarm</p> <p> Get started</p> </li> <li> <p> Tutorials</p> <p>Learn through hands-on tutorials covering common use cases</p> <p> View tutorials</p> </li> <li> <p> Examples</p> <p>Browse code examples and sample implementations</p> <p> See examples</p> </li> </ul>"},{"location":"user-guide/examples/","title":"Code Examples","text":"<p>Complete, runnable examples demonstrating key features of the drone swarm system.</p>"},{"location":"user-guide/examples/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"user-guide/examples/#simple-swarm-5-minutes","title":"Simple Swarm (5 minutes)","text":"<p>The most basic example showing system initialization and formation control.</p> <pre><code>use drone_swarm_system::{\n    types::{DroneId, Position},\n    control::swarm::{SwarmController, Formation},\n};\n\nfn main() {\n    // Initialize drone with ID\n    let drone_id = DroneId::new(1);\n\n    // Create swarm controller\n    let position = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let mut swarm = SwarmController::new(drone_id, position);\n\n    // Set formation\n    swarm.set_formation(Formation::Circle { radius: 50 });\n\n    // Compute formation position\n    let target = swarm.compute_formation_position();\n    println!(\"Target position: ({:.2}, {:.2}, {:.2})\",\n             target.x, target.y, target.z);\n}\n</code></pre> <p>Run it: <code>cargo run --example simple_swarm</code></p>"},{"location":"user-guide/examples/#encrypted-communication-10-minutes","title":"Encrypted Communication (10 minutes)","text":"<p>Demonstrates military-grade encryption and digital signatures.</p> <pre><code>use drone_swarm_system::safety::crypto::CryptoContext;\n\nfn main() {\n    // Initialize crypto context\n    let seed = [42u8; 32]; // Use hardware RNG in production\n    let crypto = CryptoContext::new(seed);\n\n    // Encrypt a message\n    let message = b\"Drone 1 reporting: Target located at (100, 200, 50)\";\n    let nonce = [0u8; 12];\n\n    let encrypted = crypto.encrypt(message, &amp;nonce);\n    println!(\"Encrypted {} bytes -&gt; {} bytes\", message.len(), encrypted.len());\n\n    // Decrypt\n    let decrypted = crypto.decrypt(&amp;encrypted, &amp;nonce).unwrap();\n    assert_eq!(message, &amp;decrypted[..]);\n    println!(\"Decryption successful!\");\n}\n</code></pre> <p>Run it: <code>cargo run --example encrypted_comms</code></p>"},{"location":"user-guide/examples/#path-planning-examples","title":"Path Planning Examples","text":""},{"location":"user-guide/examples/#pso-path-optimization","title":"PSO Path Optimization","text":"<p>Multi-waypoint path planning using Particle Swarm Optimization.</p> <pre><code>use drone_swarm_system::algorithms::pso::basic::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let start = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let goal = Position { x: 100.0, y: 100.0, z: 10.0 };\n\n    // Create path optimizer with 5 waypoints\n    let mut optimizer = DronePathOptimizer::new(start, goal, 5)?;\n\n    // Add obstacles\n    optimizer.add_obstacle(\n        Position { x: 50.0, y: 50.0, z: 10.0 },\n        20.0 // radius\n    )?;\n\n    // Optimize path (100 iterations)\n    let path = optimizer.optimize(100)?;\n\n    println!(\"Optimized path with {} waypoints:\", path.len());\n    for (i, pos) in path.iter().enumerate() {\n        println!(\"  {}: ({:.2}, {:.2}, {:.2})\", i, pos.x, pos.y, pos.z);\n    }\n\n    Ok(())\n}\n</code></pre> <p>Run it: <code>cargo run --example pso_optimization</code></p>"},{"location":"user-guide/examples/#aco-3d-path-planning","title":"ACO 3D Path Planning","text":"<p>Advanced 3D path planning with obstacle avoidance using Ant Colony Optimization.</p> <pre><code>use drone_swarm_system::aco::*;\n\nfn main() {\n    let start = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let goal = Position { x: 200.0, y: 200.0, z: 50.0 };\n\n    let config = ACOConfig {\n        num_ants: 50,\n        max_iterations: 100,\n        alpha: 1.0,      // Pheromone importance\n        beta: 2.0,       // Heuristic importance\n        evaporation: 0.1,\n        q: 100.0,        // Pheromone deposit amount\n        variant: ACOVariant::MaxMinAntSystem,\n    };\n\n    let mut optimizer = ACOPathPlanner::new(start, goal, config)\n        .expect(\"Failed to create optimizer\");\n\n    // Add 3D obstacles\n    optimizer.add_obstacle(\n        Position { x: 100.0, y: 100.0, z: 30.0 },\n        30.0\n    ).unwrap();\n\n    let result = optimizer.optimize().expect(\"Optimization failed\");\n\n    println!(\"Path found: {}\", result.is_valid);\n    println!(\"Path cost: {:.2}\", result.cost);\n    println!(\"Waypoints: {}\", result.waypoints.len());\n}\n</code></pre> <p>Run it: <code>cargo run --example aco_path_planning</code></p>"},{"location":"user-guide/examples/#swarm-intelligence-examples","title":"Swarm Intelligence Examples","text":""},{"location":"user-guide/examples/#formation-control","title":"Formation Control","text":"<p>Demonstrates multiple formation types with smooth transitions.</p> <pre><code>use drone_swarm_system::swarm::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let drone_id = DroneId::new(1);\n    let position = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let mut swarm = SwarmController::new(drone_id, position);\n\n    // Test different formations\n    let formations = vec![\n        (\"Circle\", Formation::Circle { radius: 50.0 }),\n        (\"Grid\", Formation::Grid { spacing: 20.0, rows: 5, cols: 5 }),\n        (\"Line\", Formation::Line { spacing: 10.0, direction: 0.0 }),\n        (\"V-Formation\", Formation::VFormation { angle: 45.0, spacing: 15.0 }),\n    ];\n\n    for (name, formation) in formations {\n        swarm.set_formation(formation);\n        let target_pos = swarm.get_target_position();\n        println!(\"{} formation target: ({:.2}, {:.2}, {:.2})\",\n                 name, target_pos.x, target_pos.y, target_pos.z);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"user-guide/examples/#gwo-multi-objective-optimization","title":"GWO Multi-Objective Optimization","text":"<p>Optimize swarm parameters using Grey Wolf Optimizer.</p> <pre><code>use drone_swarm_system::gwo::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    // Optimize formation parameters (spacing, altitude, speed)\n    let config = GWOConfig {\n        dimensions: 3,\n        num_wolves: 20,\n        max_iterations: 100,\n        variant: GWOVariant::Hybrid,  // GWO + PSO\n        adaptive: true,\n    };\n\n    let bounds = Bounds::new(vec![\n        (5.0, 50.0),   // spacing: 5-50m\n        (10.0, 100.0), // altitude: 10-100m\n        (1.0, 20.0),   // speed: 1-20 m/s\n    ])?;\n\n    let mut gwo = GreyWolfOptimizer::new(config, bounds)?;\n\n    // Objective: minimize energy while maintaining coverage\n    let fitness = |params: &amp;[f32]| -&gt; f32 {\n        let spacing = params[0];\n        let altitude = params[1];\n        let speed = params[2];\n\n        let energy_cost = speed * speed + altitude * 0.1;\n        let coverage_penalty = 1000.0 / spacing;\n\n        energy_cost + coverage_penalty\n    };\n\n    let result = gwo.optimize(fitness)?;\n    println!(\"Optimal parameters: spacing={:.2}m, altitude={:.2}m, speed={:.2}m/s\",\n             result.position[0], result.position[1], result.position[2]);\n\n    Ok(())\n}\n</code></pre> <p>Run it: <code>cargo run --example gwo_swarm_optimization</code></p>"},{"location":"user-guide/examples/#network-examples","title":"Network Examples","text":""},{"location":"user-guide/examples/#mesh-network-discovery","title":"Mesh Network Discovery","text":"<p>Automatic neighbor discovery and mesh formation.</p> <pre><code>use drone_swarm_system::network::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let drone_id = DroneId::new(1);\n    let mut network = MeshNetwork::new(drone_id);\n\n    // Simulate receiving Hello messages from neighbors\n    for i in 2..=5 {\n        let hello_msg = NetworkMessage::Hello {\n            sender: DroneId::new(i),\n            position: Position {\n                x: (i * 50) as f32,\n                y: 0.0,\n                z: 10.0\n            },\n            sequence: 1,\n        };\n\n        let addr = NetworkAddress::new([192, 168, 1, i as u8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 8080);\n        network.process_message(hello_msg, addr)?;\n    }\n\n    println!(\"Discovered {} neighbors\", network.neighbor_count());\n\n    Ok(())\n}\n</code></pre>"},{"location":"user-guide/examples/#federated-learning-examples","title":"Federated Learning Examples","text":""},{"location":"user-guide/examples/#distributed-model-training","title":"Distributed Model Training","text":"<p>Train ML models across the swarm while preserving privacy.</p> <pre><code>use drone_swarm_system::federated::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let drone_id = DroneId::new(1);\n\n    // Initialize global model (100 parameters)\n    let model = GlobalModel::new(100)?;\n\n    // Create local trainer\n    let mut trainer = LocalTrainer::new(drone_id, model.parameters.clone());\n\n    // Training loop\n    for epoch in 0..10 {\n        // Simulate training on local data\n        let loss = trainer.train_step(0.01)?; // learning rate = 0.01\n\n        if epoch % 2 == 0 {\n            println!(\"Epoch {}: Loss = {:.4}\", epoch, loss);\n        }\n    }\n\n    // Get updated parameters to share with swarm\n    let updated_params = trainer.get_parameters();\n    println!(\"Model trained! Ready to aggregate with swarm.\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"user-guide/examples/#security-examples","title":"Security Examples","text":""},{"location":"user-guide/examples/#intrusion-detection","title":"Intrusion Detection","text":"<p>Real-time security monitoring and threat detection.</p> <pre><code>use drone_swarm_system::security::*;\n\nfn main() -&gt; Result&lt;()&gt; {\n    let mut monitor = SecurityMonitor::new();\n\n    let attacker = DroneId::new(666);\n\n    // Simulate repeated authentication failures\n    for i in 0..15 {\n        match monitor.record_auth_failure(attacker) {\n            Ok(_) =&gt; println!(\"Auth failure {}/10\", i + 1),\n            Err(SwarmError::PermissionDenied) =&gt; {\n                println!(\"\ud83d\udea8 INTRUSION DETECTED! Drone {} banned\", attacker.as_u64());\n                break;\n            }\n            Err(e) =&gt; println!(\"Error: {:?}\", e),\n        }\n    }\n\n    // Check if banned\n    assert!(monitor.is_banned(attacker));\n\n    Ok(())\n}\n</code></pre>"},{"location":"user-guide/examples/#complete-application-examples","title":"Complete Application Examples","text":""},{"location":"user-guide/examples/#search-and-rescue-coordinator","title":"Search and Rescue Coordinator","text":"<p>Full SAR mission with 50 drones, path planning, and target detection.</p> <pre><code>// See examples/search_rescue_mission.rs for complete implementation\n// Features:\n// - Grid formation for systematic search\n// - ACO path planning with dynamic obstacles\n// - Federated learning for target detection\n// - Real-time discovery sharing\n// - Fault tolerance and recovery\n</code></pre> <p>Run it: <code>cargo run --example search_rescue_mission</code></p>"},{"location":"user-guide/examples/#agricultural-monitoring-system","title":"Agricultural Monitoring System","text":"<p>Autonomous crop monitoring with 20 drones.</p> <pre><code>// See examples/agriculture_monitor.rs for complete implementation\n// Features:\n// - Optimized field coverage patterns\n// - Collaborative pest detection\n// - PSO-based spraying route optimization\n// - Energy-efficient task allocation\n</code></pre> <p>Run it: <code>cargo run --example agriculture_monitor</code></p>"},{"location":"user-guide/examples/#embedded-examples","title":"Embedded Examples","text":""},{"location":"user-guide/examples/#stm32-bare-metal-deployment","title":"STM32 Bare-Metal Deployment","text":"<pre><code>#![no_std]\n#![no_main]\n\nuse drone_swarm_system::*;\nuse panic_halt as _;\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize time source (168 MHz STM32F4)\n    init_time_source(168_000_000);\n\n    // Initialize swarm controller\n    let drone_id = DroneId::new(1);\n    let position = Position { x: 0.0, y: 0.0, z: 10.0 };\n    let swarm = SwarmController::new(drone_id, position);\n\n    // Main loop\n    loop {\n        // Update swarm state\n        // Read sensors\n        // Send telemetry\n        // Receive commands\n\n        delay_ms(50); // 20 Hz control loop\n    }\n}\n</code></pre> <p>Build it: <code>cargo build --example stm32_deployment --target thumbv7em-none-eabihf --release</code></p>"},{"location":"user-guide/examples/#testing-examples","title":"Testing Examples","text":"<p>All examples include comprehensive tests. Run them with:</p> <pre><code># Run all example tests\ncargo test --examples\n\n# Run specific example test\ncargo test --example simple_swarm\n\n# Run with verbose output\ncargo test --example pso_optimization -- --nocapture\n</code></pre>"},{"location":"user-guide/examples/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Architecture Guide to understand system internals</li> <li>Check out Tutorials for step-by-step guides</li> <li>Review API Reference for detailed documentation</li> <li>Join the Community to ask questions</li> </ul> <p>Note: All examples are production-ready code that you can adapt for your projects. They demonstrate best practices for memory safety, error handling, and embedded systems design.</p>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will help you get the Drone Swarm Communication System up and running on your machine.</p>"},{"location":"user-guide/getting-started/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Installation</li> <li>Your First Swarm</li> <li>Basic Configuration</li> <li>Running Examples</li> <li>Next Steps</li> </ul>"},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"user-guide/getting-started/#required","title":"Required","text":"<ul> <li> <p>Rust: Version 1.70 or higher   <pre><code># Install Rust via rustup\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Verify installation\nrustc --version\ncargo --version\n</code></pre></p> </li> <li> <p>Git: For cloning the repository   <pre><code>git --version\n</code></pre></p> </li> </ul>"},{"location":"user-guide/getting-started/#optional-for-embedded-deployment","title":"Optional (for embedded deployment)","text":"<ul> <li> <p>ARM Toolchain: For embedded targets   <pre><code>rustup target add thumbv7em-none-eabihf  # Cortex-M4/M7\nrustup target add thumbv8m.main-none-eabihf  # Cortex-M33\n</code></pre></p> </li> <li> <p>probe-rs: For flashing embedded devices   <pre><code>cargo install probe-rs --features cli\n</code></pre></p> </li> </ul>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":""},{"location":"user-guide/getting-started/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/mahii6991/swarm-manager.git\ncd swarm-manager\n</code></pre>"},{"location":"user-guide/getting-started/#2-build-the-project","title":"2. Build the Project","text":"<pre><code># Debug build (faster compilation)\ncargo build\n\n# Release build (optimized)\ncargo build --release\n</code></pre>"},{"location":"user-guide/getting-started/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\ncargo test\n\n# Run tests with output\ncargo test -- --nocapture\n\n# Run specific test\ncargo test test_encryption\n</code></pre>"},{"location":"user-guide/getting-started/#4-verify-installation","title":"4. Verify Installation","text":"<pre><code># Check formatting\ncargo fmt -- --check\n\n# Run linter\ncargo clippy\n\n# Generate documentation\ncargo doc --open\n</code></pre>"},{"location":"user-guide/getting-started/#your-first-swarm","title":"Your First Swarm","text":"<p>Let's create a simple 3-drone swarm that demonstrates the core features.</p>"},{"location":"user-guide/getting-started/#step-1-create-a-new-example-file","title":"Step 1: Create a New Example File","text":"<p>Create <code>examples/my_first_swarm.rs</code>:</p> <pre><code>use drone_swarm_system::{\n    safety::crypto::CryptoContext,\n    network::core::MeshNetwork,\n    consensus::raft::ConsensusEngine,\n    control::swarm::{SwarmController, Formation},\n    types::{DroneId, Position},\n};\n\nfn main() {\n    println!(\"\ud83d\ude81 Starting My First Drone Swarm!\");\n\n    // Initialize 3 drones\n    let drones = vec![\n        create_drone(1, Position { x: 0.0, y: 0.0, z: 10.0 }),\n        create_drone(2, Position { x: 10.0, y: 0.0, z: 10.0 }),\n        create_drone(3, Position { x: 5.0, y: 8.66, z: 10.0 }),\n    ];\n\n    println!(\"\u2705 Created {} drones\", drones.len());\n\n    // Set formation\n    for (id, controller) in drones {\n        println!(\"Drone {} ready at position: {:?}\", id, controller.get_position());\n    }\n\n    println!(\"\ud83c\udfaf Swarm initialized successfully!\");\n}\n\nfn create_drone(id: u32, position: Position) -&gt; (u32, SwarmController) {\n    let drone_id = DroneId::new(id);\n    let controller = SwarmController::new(drone_id, position);\n    (id, controller)\n}\n</code></pre>"},{"location":"user-guide/getting-started/#step-2-run-your-swarm","title":"Step 2: Run Your Swarm","text":"<pre><code>cargo run --example my_first_swarm\n</code></pre> <p>Expected output: <pre><code>\ud83d\ude81 Starting My First Drone Swarm!\n\u2705 Created 3 drones\nDrone 1 ready at position: Position { x: 0.0, y: 0.0, z: 10.0 }\nDrone 2 ready at position: Position { x: 10.0, y: 0.0, z: 10.0 }\nDrone 3 ready at position: Position { x: 5.0, y: 8.66, z: 10.0 }\n\ud83c\udfaf Swarm initialized successfully!\n</code></pre></p>"},{"location":"user-guide/getting-started/#basic-configuration","title":"Basic Configuration","text":""},{"location":"user-guide/getting-started/#swarm-configuration","title":"Swarm Configuration","text":"<pre><code>use drone_swarm_system::system::config::SwarmConfig;\nuse drone_swarm_system::types::DroneId;\n\nlet drone_id = DroneId::new(1);\nlet mut config = SwarmConfig::new(drone_id);\n\n// Enable security features\nconfig.encryption_enabled = true;\nconfig.signature_verification = true;\n\n// Network settings\nconfig.max_neighbors = 10;\nconfig.comm_range = 1000.0; // 1km range\n\n// Consensus settings\nconfig.consensus_enabled = true;\nconfig.heartbeat_interval = 150; // milliseconds\n\n// Federated learning\nconfig.federated_learning_enabled = true;\nconfig.learning_rate = 0.01;\n</code></pre>"},{"location":"user-guide/getting-started/#cryptographic-setup","title":"Cryptographic Setup","text":"<pre><code>use drone_swarm_system::safety::crypto::CryptoContext;\n\n// IMPORTANT: Use hardware RNG in production!\nlet seed = [42u8; 32]; // For testing only\nlet crypto = CryptoContext::new(seed);\n\n// Encrypt a message\nlet message = b\"Hello, Swarm!\";\nlet nonce = [0u8; 12];\nlet encrypted = crypto.encrypt(message, &amp;nonce);\n\n// Decrypt\nlet decrypted = crypto.decrypt(&amp;encrypted, &amp;nonce).unwrap();\nassert_eq!(message, decrypted.as_slice());\n</code></pre>"},{"location":"user-guide/getting-started/#network-setup","title":"Network Setup","text":"<pre><code>use drone_swarm_system::network::core::MeshNetwork;\nuse drone_swarm_system::types::DroneId;\n\nlet drone_id = DroneId::new(1);\nlet mut network = MeshNetwork::new(drone_id);\n\n// Add neighbors\nnetwork.add_neighbor(DroneId::new(2), 50.0); // 50m distance\nnetwork.add_neighbor(DroneId::new(3), 75.0); // 75m distance\n\n// Send message\nlet dest = DroneId::new(2);\nlet payload = b\"Hello from Drone 1\";\nnetwork.send_message(dest, payload);\n</code></pre>"},{"location":"user-guide/getting-started/#running-examples","title":"Running Examples","text":"<p>The repository includes several examples:</p>"},{"location":"user-guide/getting-started/#1-simple-swarm","title":"1. Simple Swarm","text":"<pre><code>cargo run --example simple_swarm\n</code></pre> <p>Demonstrates basic swarm initialization and formation control.</p>"},{"location":"user-guide/getting-started/#2-encrypted-communication","title":"2. Encrypted Communication","text":"<pre><code>cargo run --example encrypted_messaging\n</code></pre> <p>Shows how to use the cryptographic layer for secure communication.</p>"},{"location":"user-guide/getting-started/#3-consensus-demo","title":"3. Consensus Demo","text":"<pre><code>cargo run --example consensus_demo\n</code></pre> <p>Demonstrates Raft consensus for distributed decision-making.</p>"},{"location":"user-guide/getting-started/#4-federated-learning","title":"4. Federated Learning","text":"<pre><code>cargo run --example federated_learning\n</code></pre> <p>Shows how drones can collaboratively train a model.</p>"},{"location":"user-guide/getting-started/#5-path-planning","title":"5. Path Planning","text":"<pre><code>cargo run --example path_planning\n</code></pre> <p>Demonstrates ACO, PSO, and GWO algorithms for optimal path finding.</p>"},{"location":"user-guide/getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Here's a typical workflow for using the system:</p> <pre><code>use drone_swarm_system::{\n    types::{DroneId, Position},\n    safety::crypto::CryptoContext,\n    network::core::MeshNetwork,\n    consensus::raft::ConsensusEngine,\n    control::swarm::{SwarmController, Formation},\n};\n\nfn main() {\n    // 1. Initialize drone\n    let drone_id = DroneId::new(1);\n    let position = Position { x: 0.0, y: 0.0, z: 10.0 };\n\n    // 2. Setup cryptography\n    let seed = get_hardware_seed(); // Use hardware RNG\n    let crypto = CryptoContext::new(seed);\n\n    // 3. Initialize network\n    let mut network = MeshNetwork::new(drone_id);\n\n    // 4. Initialize consensus\n    let mut consensus = ConsensusEngine::new(drone_id, 150);\n\n    // 5. Initialize swarm controller\n    let mut swarm = SwarmController::new(drone_id, position);\n\n    // 6. Set formation\n    swarm.set_formation(Formation::Grid { spacing: 20 });\n\n    // 7. Main loop\n    loop {\n        // Receive messages\n        if let Some(msg) = network.receive() {\n            // Decrypt message\n            let decrypted = crypto.decrypt(&amp;msg.payload, &amp;msg.nonce).unwrap();\n\n            // Process message\n            handle_message(decrypted);\n        }\n\n        // Update consensus\n        consensus.tick();\n\n        // Update position\n        swarm.update_position();\n\n        // Sleep\n        std::thread::sleep(std::time::Duration::from_millis(10));\n    }\n}\n\nfn get_hardware_seed() -&gt; [u8; 32] {\n    // TODO: Implement hardware RNG\n    [0u8; 32]\n}\n\nfn handle_message(msg: Vec&lt;u8&gt;) {\n    println!(\"Received: {:?}\", msg);\n}\n</code></pre>"},{"location":"user-guide/getting-started/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/getting-started/#issue-compilation-errors","title":"Issue: Compilation Errors","text":"<p>Problem: Missing dependencies or incompatible Rust version</p> <p>Solution: <pre><code># Update Rust\nrustup update\n\n# Clean and rebuild\ncargo clean\ncargo build\n</code></pre></p>"},{"location":"user-guide/getting-started/#issue-tests-failing","title":"Issue: Tests Failing","text":"<p>Problem: Some tests may fail due to timing issues</p> <p>Solution: <pre><code># Run tests sequentially\ncargo test -- --test-threads=1\n\n# Run with verbose output\ncargo test -- --nocapture\n</code></pre></p>"},{"location":"user-guide/getting-started/#issue-performance-issues","title":"Issue: Performance Issues","text":"<p>Problem: Debug builds are slow</p> <p>Solution: Always use release builds for performance testing: <pre><code>cargo build --release\ncargo test --release\n</code></pre></p>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics working:</p> <ol> <li>Read the Architecture Guide - Understand the system design</li> <li>Explore the API Reference - Learn about all available modules</li> <li>Review Security Best Practices - Secure your deployment</li> <li>Check out Examples - See real-world usage</li> </ol>"},{"location":"user-guide/getting-started/#getting-help","title":"Getting Help","text":"<p>If you run into issues:</p> <ul> <li>Check the FAQ</li> <li>Search GitHub Issues</li> <li>Ask in GitHub Discussions</li> </ul>"},{"location":"user-guide/getting-started/#embedded-deployment","title":"Embedded Deployment","text":"<p>For deploying to embedded systems (STM32, ESP32, etc.):</p> <pre><code># Add target\nrustup target add thumbv7em-none-eabihf\n\n# Build for embedded\ncargo build --release --target thumbv7em-none-eabihf --no-default-features\n\n# Flash to device\nprobe-rs run --chip STM32F407VGTx target/thumbv7em-none-eabihf/release/swarm-manager\n</code></pre> <p>See the hardware guides (ESP32, STM32, PX4) for detailed instructions.</p> <p>Ready to build your swarm? Check out the Examples directory for more advanced use cases!</p>"},{"location":"user-guide/tutorials/","title":"Tutorials","text":"<p>Step-by-step guides to help you build real-world drone swarm applications.</p>"},{"location":"user-guide/tutorials/#getting-started-tutorials","title":"Getting Started Tutorials","text":""},{"location":"user-guide/tutorials/#your-first-swarm","title":"Your First Swarm","text":"<p>Create a simple 3-drone swarm with formation control and mesh networking in under 10 minutes. See the examples directory.</p>"},{"location":"user-guide/tutorials/#path-planning-with-pso","title":"Path Planning with PSO","text":"<p>Implement particle swarm optimization for efficient multi-waypoint navigation. Run <code>cargo run --example pso_optimization</code>.</p>"},{"location":"user-guide/tutorials/#secure-communication","title":"Secure Communication","text":"<p>Set up end-to-end encrypted communication with military-grade cryptography. See Security Guide.</p>"},{"location":"user-guide/tutorials/#hardware-integration","title":"Hardware Integration","text":""},{"location":"user-guide/tutorials/#stm32-deployment","title":"STM32 Deployment","text":"<p>Deploy your swarm system on STM32F4/F7 microcontrollers with embedded HAL. See STM32 Guide.</p>"},{"location":"user-guide/tutorials/#esp32-wifi-mesh","title":"ESP32 WiFi Mesh","text":"<p>Build a WiFi mesh network using ESP32 for cost-effective swarm communication. See ESP32 Guide.</p>"},{"location":"user-guide/tutorials/#px4ardupilot-integration","title":"PX4/ArduPilot Integration","text":"<p>Integrate with popular flight controllers using MAVLink protocol. See PX4 Guide.</p>"},{"location":"user-guide/tutorials/#algorithm-deep-dives","title":"Algorithm Deep Dives","text":""},{"location":"user-guide/tutorials/#implementing-custom-pso-topologies","title":"Implementing Custom PSO Topologies","text":"<p>Learn how to create custom particle swarm topologies for specific optimization problems. Run <code>cargo run --example pso_optimization</code>.</p>"},{"location":"user-guide/tutorials/#aco-for-3d-path-planning","title":"ACO for 3D Path Planning","text":"<p>Master ant colony optimization for obstacle avoidance in 3D environments. Run <code>cargo run --example aco_path_planning</code>.</p>"},{"location":"user-guide/tutorials/#grey-wolf-optimizer","title":"Grey Wolf Optimizer","text":"<p>Fine-tune GWO parameters for multi-objective swarm coordination. Run <code>cargo run --example gwo_swarm_optimization</code>.</p>"},{"location":"user-guide/tutorials/#example-projects","title":"Example Projects","text":"<p>Check out the examples directory for runnable demonstrations:</p> <ul> <li><code>simple_swarm.rs</code> - Basic swarm initialization</li> <li><code>pso_optimization.rs</code> - Particle swarm optimization</li> <li><code>aco_path_planning.rs</code> - Ant colony path planning</li> <li><code>gwo_swarm_optimization.rs</code> - Grey wolf optimizer</li> <li><code>collision_avoidance_demo.rs</code> - Collision avoidance algorithms</li> <li><code>telemetry_monitoring.rs</code> - Telemetry and monitoring</li> </ul> <p>Need help? Ask on GitHub Discussions.</p>"}]}